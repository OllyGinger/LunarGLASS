
Top IR:
; ModuleID = 'Glslang'

%s2 = type { i32, float, %s1 }
%s1 = type { i32, float }

@u = global <4 x float> zeroinitializer
@w = global <4 x float> zeroinitializer
@foo2a = external addrspace(2) constant %s2
@foo2b = external addrspace(2) constant %s2
@sampler = external addrspace(1) constant i32
@coord = global <2 x float> zeroinitializer
@gl_FragColor = global <4 x float> zeroinitializer
@foo1 = external addrspace(2) constant %s1

define fastcc void @main() {
entry:
  %v = alloca <4 x float>
  %constructed6 = alloca [3 x %s1]
  %constructed5 = alloca %s1
  %constructed4 = alloca %s1
  %b = alloca [3 x %s1]
  %constructed2 = alloca [3 x %s1]
  %constructed1 = alloca %s1
  %constructed = alloca %s1
  %a = alloca [3 x %s1]
  %0 = load <4 x float>* @u
  %1 = extractelement <4 x float> %0, i32 0
  %2 = fptosi float %1 to i32
  %3 = load <4 x float>* @u
  %4 = extractelement <4 x float> %3, i32 1
  %5 = getelementptr %s1* %constructed, i32 0, i32 0
  store i32 %2, i32* %5
  %6 = getelementptr %s1* %constructed, i32 0, i32 1
  store float %4, float* %6
  %7 = load %s1* %constructed
  %8 = load <4 x float>* @u
  %9 = extractelement <4 x float> %8, i32 2
  %10 = fptosi float %9 to i32
  %11 = load <4 x float>* @u
  %12 = extractelement <4 x float> %11, i32 3
  %13 = getelementptr %s1* %constructed1, i32 0, i32 0
  store i32 %10, i32* %13
  %14 = getelementptr %s1* %constructed1, i32 0, i32 1
  store float %12, float* %14
  %15 = load %s1* %constructed1
  %16 = getelementptr [3 x %s1]* %constructed2, i32 0, i32 0
  store %s1 %7, %s1* %16
  %17 = getelementptr [3 x %s1]* %constructed2, i32 0, i32 1
  store %s1 %15, %s1* %17
  %18 = getelementptr [3 x %s1]* %constructed2, i32 0, i32 2
  store %s1 { i32 14, float 1.400000e+01 }, %s1* %18
  %a3 = load [3 x %s1]* %constructed2
  store [3 x %s1] %a3, [3 x %s1]* %a
  %19 = load <4 x float>* @w
  %20 = extractelement <4 x float> %19, i32 0
  %21 = fptosi float %20 to i32
  %22 = load <4 x float>* @w
  %23 = extractelement <4 x float> %22, i32 1
  %24 = getelementptr %s1* %constructed4, i32 0, i32 0
  store i32 %21, i32* %24
  %25 = getelementptr %s1* %constructed4, i32 0, i32 1
  store float %23, float* %25
  %26 = load %s1* %constructed4
  %27 = load <4 x float>* @w
  %28 = extractelement <4 x float> %27, i32 2
  %29 = fptosi float %28 to i32
  %30 = load <4 x float>* @w
  %31 = extractelement <4 x float> %30, i32 3
  %32 = getelementptr %s1* %constructed5, i32 0, i32 0
  store i32 %29, i32* %32
  %33 = getelementptr %s1* %constructed5, i32 0, i32 1
  store float %31, float* %33
  %34 = load %s1* %constructed5
  %35 = getelementptr [3 x %s1]* %constructed6, i32 0, i32 0
  store %s1 { i32 17, float 1.700000e+01 }, %s1* %35
  %36 = getelementptr [3 x %s1]* %constructed6, i32 0, i32 1
  store %s1 %26, %s1* %36
  %37 = getelementptr [3 x %s1]* %constructed6, i32 0, i32 2
  store %s1 %34, %s1* %37
  %b7 = load [3 x %s1]* %constructed6
  store [3 x %s1] %b7, [3 x %s1]* %b
  %38 = load %s2 addrspace(2)* @foo2a, !gla.uniform !7
  %39 = load %s2 addrspace(2)* @foo2b, !gla.uniform !13
  %element1 = extractvalue %s2 %38, 0
  %element2 = extractvalue %s2 %39, 0
  %40 = icmp eq i32 %element1, %element2
  %element18 = extractvalue %s2 %38, 1
  %element29 = extractvalue %s2 %39, 1
  %41 = fcmp oeq float %element18, %element29
  %42 = and i1 %40, %41
  %element110 = extractvalue %s2 %38, 2
  %element211 = extractvalue %s2 %39, 2
  %element112 = extractvalue %s1 %element110, 0
  %element213 = extractvalue %s1 %element211, 0
  %43 = icmp eq i32 %element112, %element213
  %element114 = extractvalue %s1 %element110, 1
  %element215 = extractvalue %s1 %element211, 1
  %44 = fcmp oeq float %element114, %element215
  %45 = and i1 %43, %44
  %46 = and i1 %42, %45
  br i1 %46, label %then, label %else

then:                                             ; preds = %entry
  %47 = load i32 addrspace(1)* @sampler, !gla.uniform !14
  %48 = load <2 x float>* @coord
  %v16 = call <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32 2, i32 %47, i32 0, <2 x float> %48)
  store <4 x float> %v16, <4 x float>* %v
  br label %ifmerge

else:                                             ; preds = %entry
  %49 = load i32 addrspace(1)* @sampler, !gla.uniform !14
  %50 = load <2 x float>* @coord
  %51 = fmul <2 x float> <float 2.000000e+00, float 2.000000e+00>, %50
  %v17 = call <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32 2, i32 %49, i32 0, <2 x float> %51)
  store <4 x float> %v17, <4 x float>* %v
  br label %ifmerge

ifmerge:                                          ; preds = %else, %then
  %52 = load <4 x float>* @u
  %53 = load <4 x float>* %v
  %54 = fcmp oeq <4 x float> %52, %53
  %55 = call i1 @llvm.gla.all.v4i1(<4 x i1> %54)
  br i1 %55, label %then18, label %ifmerge20

then18:                                           ; preds = %ifmerge
  %56 = load <4 x float>* %v
  %v19 = fmul <4 x float> %56, <float 3.000000e+00, float 3.000000e+00, float 3.000000e+00, float 3.000000e+00>
  store <4 x float> %v19, <4 x float>* %v
  br label %ifmerge20

ifmerge20:                                        ; preds = %ifmerge, %then18
  %57 = load <4 x float>* @u
  %58 = load <4 x float>* %v
  %59 = fcmp one <4 x float> %57, %58
  %60 = call i1 @llvm.gla.any.v4i1(<4 x i1> %59)
  br i1 %60, label %then21, label %ifmerge23

then21:                                           ; preds = %ifmerge20
  %61 = load <4 x float>* %v
  %v22 = fmul <4 x float> %61, <float 4.000000e+00, float 4.000000e+00, float 4.000000e+00, float 4.000000e+00>
  store <4 x float> %v22, <4 x float>* %v
  br label %ifmerge23

ifmerge23:                                        ; preds = %ifmerge20, %then21
  %62 = load <2 x float>* @coord
  %63 = load <4 x float>* %v
  %64 = extractelement <4 x float> %63, i32 1
  %65 = insertelement <2 x float> undef, float %64, i32 0
  %66 = extractelement <4 x float> %63, i32 3
  %67 = insertelement <2 x float> %65, float %66, i32 1
  %68 = fcmp oeq <2 x float> %62, %67
  %69 = call i1 @llvm.gla.all.v2i1(<2 x i1> %68)
  br i1 %69, label %then24, label %ifmerge26

then24:                                           ; preds = %ifmerge23
  %70 = load <4 x float>* %v
  %v25 = fmul <4 x float> %70, <float 5.000000e+00, float 5.000000e+00, float 5.000000e+00, float 5.000000e+00>
  store <4 x float> %v25, <4 x float>* %v
  br label %ifmerge26

ifmerge26:                                        ; preds = %ifmerge23, %then24
  %71 = load [3 x %s1]* %a
  %72 = load [3 x %s1]* %b
  %element127 = extractvalue [3 x %s1] %71, 0
  %element228 = extractvalue [3 x %s1] %72, 0
  %element129 = extractvalue %s1 %element127, 0
  %element230 = extractvalue %s1 %element228, 0
  %73 = icmp eq i32 %element129, %element230
  %element131 = extractvalue %s1 %element127, 1
  %element232 = extractvalue %s1 %element228, 1
  %74 = fcmp oeq float %element131, %element232
  %75 = and i1 %73, %74
  %element133 = extractvalue [3 x %s1] %71, 1
  %element234 = extractvalue [3 x %s1] %72, 1
  %element135 = extractvalue %s1 %element133, 0
  %element236 = extractvalue %s1 %element234, 0
  %76 = icmp eq i32 %element135, %element236
  %element137 = extractvalue %s1 %element133, 1
  %element238 = extractvalue %s1 %element234, 1
  %77 = fcmp oeq float %element137, %element238
  %78 = and i1 %76, %77
  %79 = and i1 %75, %78
  %element139 = extractvalue [3 x %s1] %71, 2
  %element240 = extractvalue [3 x %s1] %72, 2
  %element141 = extractvalue %s1 %element139, 0
  %element242 = extractvalue %s1 %element240, 0
  %80 = icmp eq i32 %element141, %element242
  %element143 = extractvalue %s1 %element139, 1
  %element244 = extractvalue %s1 %element240, 1
  %81 = fcmp oeq float %element143, %element244
  %82 = and i1 %80, %81
  %83 = and i1 %79, %82
  br i1 %83, label %then45, label %ifmerge47

then45:                                           ; preds = %ifmerge26
  %84 = load <4 x float>* %v
  %v46 = fmul <4 x float> %84, <float 6.000000e+00, float 6.000000e+00, float 6.000000e+00, float 6.000000e+00>
  store <4 x float> %v46, <4 x float>* %v
  br label %ifmerge47

ifmerge47:                                        ; preds = %ifmerge26, %then45
  %85 = load [3 x %s1]* %a
  %86 = load [3 x %s1]* %b
  %element148 = extractvalue [3 x %s1] %85, 0
  %element249 = extractvalue [3 x %s1] %86, 0
  %element150 = extractvalue %s1 %element148, 0
  %element251 = extractvalue %s1 %element249, 0
  %87 = icmp ne i32 %element150, %element251
  %element152 = extractvalue %s1 %element148, 1
  %element253 = extractvalue %s1 %element249, 1
  %88 = fcmp one float %element152, %element253
  %89 = or i1 %87, %88
  %element154 = extractvalue [3 x %s1] %85, 1
  %element255 = extractvalue [3 x %s1] %86, 1
  %element156 = extractvalue %s1 %element154, 0
  %element257 = extractvalue %s1 %element255, 0
  %90 = icmp ne i32 %element156, %element257
  %element158 = extractvalue %s1 %element154, 1
  %element259 = extractvalue %s1 %element255, 1
  %91 = fcmp one float %element158, %element259
  %92 = or i1 %90, %91
  %93 = or i1 %89, %92
  %element160 = extractvalue [3 x %s1] %85, 2
  %element261 = extractvalue [3 x %s1] %86, 2
  %element162 = extractvalue %s1 %element160, 0
  %element263 = extractvalue %s1 %element261, 0
  %94 = icmp ne i32 %element162, %element263
  %element164 = extractvalue %s1 %element160, 1
  %element265 = extractvalue %s1 %element261, 1
  %95 = fcmp one float %element164, %element265
  %96 = or i1 %94, %95
  %97 = or i1 %93, %96
  br i1 %97, label %then66, label %ifmerge68

then66:                                           ; preds = %ifmerge47
  %98 = load <4 x float>* %v
  %v67 = fmul <4 x float> %98, <float 7.000000e+00, float 7.000000e+00, float 7.000000e+00, float 7.000000e+00>
  store <4 x float> %v67, <4 x float>* %v
  br label %ifmerge68

ifmerge68:                                        ; preds = %ifmerge47, %then66
  %gl_FragColor = load <4 x float>* %v
  store <4 x float> %gl_FragColor, <4 x float>* @gl_FragColor
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %ifmerge68
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32, i32, i32, <2 x float>) #0

; Function Attrs: nounwind readnone
declare i1 @llvm.gla.all.v4i1(<4 x i1>) #0

; Function Attrs: nounwind readnone
declare i1 @llvm.gla.any.v4i1(<4 x i1>) #0

; Function Attrs: nounwind readnone
declare i1 @llvm.gla.all.v2i1(<2 x i1>) #0

attributes #0 = { nounwind readnone }

!gla.entrypoint = !{!0}
!gla.inputs = !{!1, !3, !5}
!gla.uniforms = !{!7, !13, !14, !17}
!gla.outputs = !{!18}
!gla.noStaticUse = !{!17}

!0 = metadata !{metadata !"main", i32 15}
!1 = metadata !{metadata !"u", i32 1, <4 x float>* @u_typeProxy, metadata !2}
!2 = metadata !{i32 0, i32 0, i32 1024, null, i32 1}
!3 = metadata !{metadata !"w", i32 1, <4 x float>* @w_typeProxy, metadata !4}
!4 = metadata !{i32 0, i32 0, i32 1025, null, i32 1}
!5 = metadata !{metadata !"coord", i32 1, <2 x float>* @coord_typeProxy, metadata !6}
!6 = metadata !{i32 0, i32 0, i32 1026, null, i32 1}
!7 = metadata !{metadata !"foo2a", i32 12, %s2* @foo2a_typeProxy, metadata !8, metadata !9}
!8 = metadata !{i32 4, i32 0, i32 1024, null}
!9 = metadata !{metadata !"s2", metadata !8, metadata !"i", metadata !10, metadata !"f", metadata !10, metadata !"s1_1", metadata !12}
!10 = metadata !{metadata !"", metadata !11}
!11 = metadata !{i32 0, i32 0, i32 1024, null}
!12 = metadata !{metadata !"s1", metadata !8, metadata !"i", metadata !10, metadata !"f", metadata !10}
!13 = metadata !{metadata !"foo2b", i32 12, %s2* @foo2b_typeProxy, metadata !8, metadata !9}
!14 = metadata !{metadata !"sampler", i32 12, i32* @sampler_typeProxy, metadata !15}
!15 = metadata !{i32 5, i32 0, i32 1024, metadata !16}
!16 = metadata !{i32 0, i32* @sampler_typeProxy, i32 1, i1 false, i1 false, i32 0}
!17 = metadata !{metadata !"foo1", i32 12, %s1* @foo1_typeProxy, metadata !8, metadata !12}
!18 = metadata !{metadata !"gl_FragColor", i32 7, <4 x float>* @gl_FragColor_typeProxy, metadata !19}
!19 = metadata !{i32 0, i32 0, i32 1027, null, i32 0}


Bottom IR:
; ModuleID = 'Glslang'

%s2 = type { i32, float, %s1 }
%s1 = type { i32, float }

@u = global <4 x float> zeroinitializer
@w = global <4 x float> zeroinitializer
@foo2a = external addrspace(2) constant %s2
@foo2b = external addrspace(2) constant %s2
@sampler = external addrspace(1) constant i32
@coord = global <2 x float> zeroinitializer
@gl_FragColor = global <4 x float> zeroinitializer

define fastcc void @main() {
entry:
  %0 = load <4 x float>* @u, align 16
  %1 = extractelement <4 x float> %0, i32 0
  %2 = fptosi float %1 to i32
  %3 = extractelement <4 x float> %0, i32 1
  %4 = extractelement <4 x float> %0, i32 2
  %5 = fptosi float %4 to i32
  %6 = extractelement <4 x float> %0, i32 3
  %7 = load <4 x float>* @w, align 16
  %8 = extractelement <4 x float> %7, i32 0
  %9 = fptosi float %8 to i32
  %10 = extractelement <4 x float> %7, i32 1
  %11 = extractelement <4 x float> %7, i32 2
  %12 = fptosi float %11 to i32
  %13 = extractelement <4 x float> %7, i32 3
  %14 = load %s2 addrspace(2)* @foo2a, align 4, !gla.uniform !7
  %15 = load %s2 addrspace(2)* @foo2b, align 4, !gla.uniform !13
  %element1 = extractvalue %s2 %14, 0
  %element2 = extractvalue %s2 %15, 0
  %16 = icmp eq i32 %element1, %element2
  %element18 = extractvalue %s2 %14, 1
  %element29 = extractvalue %s2 %15, 1
  %17 = fcmp oeq float %element18, %element29
  %18 = and i1 %16, %17
  %element110 = extractvalue %s2 %14, 2
  %element211 = extractvalue %s2 %15, 2
  %element112 = extractvalue %s1 %element110, 0
  %element213 = extractvalue %s1 %element211, 0
  %19 = icmp eq i32 %element112, %element213
  %element114 = extractvalue %s1 %element110, 1
  %element215 = extractvalue %s1 %element211, 1
  %20 = fcmp oeq float %element114, %element215
  %21 = and i1 %19, %20
  %22 = and i1 %18, %21
  %23 = load i32 addrspace(1)* @sampler, align 4, !gla.uniform !14
  %24 = load <2 x float>* @coord, align 8
  br i1 %22, label %then, label %else

then:                                             ; preds = %entry
  %v16 = call <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32 2, i32 %23, i32 0, <2 x float> %24)
  br label %ifmerge

else:                                             ; preds = %entry
  %25 = fmul <2 x float> %24, <float 2.000000e+00, float 2.000000e+00>
  %v17 = call <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32 2, i32 %23, i32 0, <2 x float> %25)
  br label %ifmerge

ifmerge:                                          ; preds = %else, %then
  %v.0 = phi <4 x float> [ %v16, %then ], [ %v17, %else ]
  %26 = fcmp oeq <4 x float> %0, %v.0
  %27 = call i1 @llvm.gla.all.v4i1(<4 x i1> %26)
  %v19 = fmul <4 x float> %v.0, <float 3.000000e+00, float 3.000000e+00, float 3.000000e+00, float 3.000000e+00>
  %select127 = select i1 %27, <4 x float> %v19, <4 x float> %v.0
  %28 = fcmp one <4 x float> %0, %select127
  %29 = call i1 @llvm.gla.any.v4i1(<4 x i1> %28)
  %v22 = fmul <4 x float> %select127, <float 4.000000e+00, float 4.000000e+00, float 4.000000e+00, float 4.000000e+00>
  %select = select i1 %29, <4 x float> %v22, <4 x float> %select127
  %30 = call <2 x float> @llvm.gla.fSwizzle.v2f32.v4f32.v2i32(<4 x float> %select, <2 x i32> <i32 1, i32 3>)
  %31 = fcmp oeq <2 x float> %24, %30
  %32 = call i1 @llvm.gla.all.v2i1(<2 x i1> %31)
  %v25 = fmul <4 x float> %select, <float 5.000000e+00, float 5.000000e+00, float 5.000000e+00, float 5.000000e+00>
  %select129 = select i1 %32, <4 x float> %v25, <4 x float> %select
  %33 = icmp eq i32 %2, 17
  %34 = fcmp oeq float %3, 1.700000e+01
  %35 = and i1 %33, %34
  %36 = icmp eq i32 %5, %9
  %37 = fcmp oeq float %6, %10
  %38 = and i1 %36, %37
  %39 = and i1 %35, %38
  %40 = icmp eq i32 %12, 14
  %41 = fcmp oeq float %13, 1.400000e+01
  %42 = and i1 %40, %41
  %43 = and i1 %39, %42
  %v46 = fmul <4 x float> %select129, <float 6.000000e+00, float 6.000000e+00, float 6.000000e+00, float 6.000000e+00>
  %select128 = select i1 %43, <4 x float> %v46, <4 x float> %select129
  %44 = icmp ne i32 %2, 17
  %45 = fcmp one float %3, 1.700000e+01
  %46 = or i1 %44, %45
  %47 = icmp ne i32 %5, %9
  %48 = fcmp one float %6, %10
  %49 = or i1 %47, %48
  %50 = or i1 %46, %49
  %51 = icmp ne i32 %12, 14
  %52 = fcmp one float %13, 1.400000e+01
  %53 = or i1 %51, %52
  %54 = or i1 %50, %53
  %v67 = fmul <4 x float> %select128, <float 7.000000e+00, float 7.000000e+00, float 7.000000e+00, float 7.000000e+00>
  %select130 = select i1 %54, <4 x float> %v67, <4 x float> %select128
  store <4 x float> %select130, <4 x float>* @gl_FragColor, align 16
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %ifmerge
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32, i32, i32, <2 x float>) #0

; Function Attrs: nounwind readnone
declare i1 @llvm.gla.all.v4i1(<4 x i1>) #0

; Function Attrs: nounwind readnone
declare i1 @llvm.gla.any.v4i1(<4 x i1>) #0

; Function Attrs: nounwind readnone
declare i1 @llvm.gla.all.v2i1(<2 x i1>) #0

; Function Attrs: nounwind readnone
declare <2 x float> @llvm.gla.fSwizzle.v2f32.v4f32.v2i32(<4 x float>, <2 x i32>) #0

attributes #0 = { nounwind readnone }

!gla.entrypoint = !{!0}
!gla.inputs = !{!1, !3, !5}
!gla.uniforms = !{!7, !13, !14, !17}
!gla.outputs = !{!18}
!gla.noStaticUse = !{!17}

!0 = metadata !{metadata !"main", i32 15}
!1 = metadata !{metadata !"u", i32 1, <4 x float>* @u_typeProxy, metadata !2}
!2 = metadata !{i32 0, i32 0, i32 1024, null, i32 1}
!3 = metadata !{metadata !"w", i32 1, <4 x float>* @w_typeProxy, metadata !4}
!4 = metadata !{i32 0, i32 0, i32 1025, null, i32 1}
!5 = metadata !{metadata !"coord", i32 1, <2 x float>* @coord_typeProxy, metadata !6}
!6 = metadata !{i32 0, i32 0, i32 1026, null, i32 1}
!7 = metadata !{metadata !"foo2a", i32 12, %s2* @foo2a_typeProxy, metadata !8, metadata !9}
!8 = metadata !{i32 4, i32 0, i32 1024, null}
!9 = metadata !{metadata !"s2", metadata !8, metadata !"i", metadata !10, metadata !"f", metadata !10, metadata !"s1_1", metadata !12}
!10 = metadata !{metadata !"", metadata !11}
!11 = metadata !{i32 0, i32 0, i32 1024, null}
!12 = metadata !{metadata !"s1", metadata !8, metadata !"i", metadata !10, metadata !"f", metadata !10}
!13 = metadata !{metadata !"foo2b", i32 12, %s2* @foo2b_typeProxy, metadata !8, metadata !9}
!14 = metadata !{metadata !"sampler", i32 12, i32* @sampler_typeProxy, metadata !15}
!15 = metadata !{i32 5, i32 0, i32 1024, metadata !16}
!16 = metadata !{i32 0, i32* @sampler_typeProxy, i32 1, i1 false, i1 false, i32 0}
!17 = metadata !{metadata !"foo1", i32 12, %s1* @foo1_typeProxy, metadata !8, metadata !12}
!18 = metadata !{metadata !"gl_FragColor", i32 7, <4 x float>* @gl_FragColor_typeProxy, metadata !19}
!19 = metadata !{i32 0, i32 0, i32 1027, null, i32 0}
#version 130
// LunarGOO output
struct s1 {
	int i;
	float f;
};
struct s2 {
	int i;
	float f;
	s1 s1_1;
};
uniform s2 foo2a;
uniform s2 foo2b;
uniform sampler2D sampler;
uniform s1 foo1;
in vec4 u;
in vec4 w;
in vec2 coord;
const vec2 L_6 = vec2(2.0);
const vec4 L_9 = vec4(3.0);
const vec4 L_c = vec4(4.0);
const vec4 L_10 = vec4(5.0);
const int L_12 = 17;
const float L_13 = 17.0;
const int L_14 = 14;
const float L_15 = 14.0;
const vec4 L_17 = vec4(6.0);
const vec4 L_1a = vec4(7.0);

void main()
{
	vec4 v_uc1;
	s1 element_c2 = foo2a.s1_1;
	s1 element_c3 = foo2b.s1_1;
	bool L_4 = (((foo2a.i) == (foo2b.i)) && ((foo2a.f) == (foo2b.f))) && (((element_c2.i) == (element_c3.i)) && ((element_c2.f) == (element_c3.f)));
	if (L_4) {
		vec4 L_5 = texture(sampler, coord);
		v_uc1 = L_5;
	} else {
		vec4 L_7 = texture(sampler, (coord * L_6));
		v_uc1 = L_7;
	}
	
	bool L_8 = all((equal(u, v_uc1)));
	vec4 select_c4 = L_8 ? (v_uc1 * L_9) : v_uc1;
	bool L_b = any((notEqual(u, select_c4)));
	vec4 select_c5 = L_b ? (select_c4 * L_c) : select_c4;
	vec2 L_e = select_c5.yw;
	bool L_f = all((equal(coord, L_e)));
	vec4 select_c6 = L_f ? (select_c5 * L_10) : select_c5;
	bool L_16 = ((((int(u.x)) == L_12) && (u.y == L_13)) && (((int(u.z)) == (int(w.x))) && (u.w == w.y))) && (((int(w.z)) == L_14) && (w.w == L_15));
	vec4 select_c7 = L_16 ? (select_c6 * L_17) : select_c6;
	bool L_19 = ((((int(u.x)) != L_12) || (u.y != L_13)) || (((int(u.z)) != (int(w.x))) || (u.w != w.y))) || (((int(w.z)) != L_14) || (w.w != L_15));
	gl_FragColor = (L_19 ? (select_c7 * L_1a) : select_c7);
	
}

#version 130
// LunarGOO output
struct s1 {
	int i;
	float f;
};
struct s2 {
	int i;
	float f;
	s1 s1_1;
};
uniform s2 foo2a;
uniform s2 foo2b;
uniform sampler2D sampler;
uniform s1 foo1;
in vec2 coord;
in vec4 u;
in vec4 w;
const vec2 L_4 = vec2(2.0);
const vec4 L_7 = vec4(3.0);
const vec4 L_a = vec4(4.0);
const vec4 L_e = vec4(5.0);
const int L_11 = 17;
const float L_12 = 17.0;
const int L_16 = 14;
const float L_17 = 14.0;
const vec4 L_18 = vec4(6.0);
const vec4 L_1a = vec4(7.0);

void main()
{
	vec4 v_uc_c1;
	bool L_uc2 = ((foo2a.i == foo2b.i) && (foo2a.f == foo2b.f)) && (((foo2a.s1_1.i) == (foo2b.s1_1.i)) && ((foo2a.s1_1.f) == (foo2b.s1_1.f)));
	if (L_uc2) {
		vec4 L_uc3 = texture(sampler, coord);
		v_uc_c1 = L_uc3;
	} else {
		vec4 L_uc4 = texture(sampler, (coord * L_4));
		v_uc_c1 = L_uc4;
	}
	
	bool L_uc5 = all((equal(u, v_uc_c1)));
	vec4 select_c6 = L_uc5 ? (v_uc_c1 * L_7) : v_uc_c1;
	bool L_b_c7 = any((notEqual(u, select_c6)));
	vec4 select_c8 = L_b_c7 ? (select_c6 * L_a) : select_c6;
	vec2 L_c = select_c8.yw;
	bool L_f_c9 = all((equal(coord, L_c)));
	vec4 select_c10 = L_f_c9 ? (select_c8 * L_e) : select_c8;
	int L_10 = int(u.x);
	int L_13 = int(u.z);
	int L_14 = int(w.x);
	int L_15 = int(w.z);
	vec4 select_c11 = ((((L_10 == L_11) && (u.y == L_12)) && ((L_13 == L_14) && (u.w == w.y))) && ((L_15 == L_16) && (w.w == L_17))) ? (select_c10 * L_18) : select_c10;
	vec4 select_c12 = ((((L_10 != L_11) || (u.y != L_12)) || ((L_13 != L_14) || (u.w != w.y))) || ((L_15 != L_16) || (w.w != L_17))) ? (select_c11 * L_1a) : select_c11;
	gl_FragColor = select_c12;
	
}

