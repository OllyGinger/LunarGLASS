
Top IR:
; ModuleID = 'Glslang'

@glPos_shadow = internal global <4 x float> zeroinitializer
@mvp = external addrspace(2) constant [4 x <4 x float>]
@v_shadow = internal global <4 x float> zeroinitializer
@f_shadow = internal global float 0.000000e+00
@am3_shadow = internal global [3 x <3 x float>] zeroinitializer
@arraym_shadow = internal global [3 x [4 x <4 x float>]] zeroinitializer
@VertexID_shadow = internal global i32 0
@InstanceID_shadow = internal global i32 0

define fastcc void @main() {
entry:
  %0 = alloca <4 x float>
  %1 = load [4 x <4 x float>] addrspace(2)* @mvp, !gla.uniform !5
  %v = call <4 x float> @llvm.gla.fReadData.v4f32(i32 1025, i32 -1), !gla.input !7
  store <4 x float> %v, <4 x float>* @v_shadow
  %2 = load <4 x float>* @v_shadow
  %3 = load <4 x float>* %0
  %component = extractelement <4 x float> %2, i32 0
  %component1 = extractelement <4 x float> %2, i32 1
  %component2 = extractelement <4 x float> %2, i32 2
  %component3 = extractelement <4 x float> %2, i32 3
  %column = extractvalue [4 x <4 x float>] %1, 0
  %element = extractelement <4 x float> %column, i32 0
  %product = fmul float %element, %component
  %column4 = extractvalue [4 x <4 x float>] %1, 1
  %element5 = extractelement <4 x float> %column4, i32 0
  %product6 = fmul float %element5, %component1
  %dotProduct = fadd float %product, %product6
  %column7 = extractvalue [4 x <4 x float>] %1, 2
  %element8 = extractelement <4 x float> %column7, i32 0
  %product9 = fmul float %element8, %component2
  %dotProduct10 = fadd float %dotProduct, %product9
  %column11 = extractvalue [4 x <4 x float>] %1, 3
  %element12 = extractelement <4 x float> %column11, i32 0
  %product13 = fmul float %element12, %component3
  %dotProduct14 = fadd float %dotProduct10, %product13
  %4 = insertelement <4 x float> %3, float %dotProduct14, i32 0
  %column15 = extractvalue [4 x <4 x float>] %1, 0
  %element16 = extractelement <4 x float> %column15, i32 1
  %product17 = fmul float %element16, %component
  %column18 = extractvalue [4 x <4 x float>] %1, 1
  %element19 = extractelement <4 x float> %column18, i32 1
  %product20 = fmul float %element19, %component1
  %dotProduct21 = fadd float %product17, %product20
  %column22 = extractvalue [4 x <4 x float>] %1, 2
  %element23 = extractelement <4 x float> %column22, i32 1
  %product24 = fmul float %element23, %component2
  %dotProduct25 = fadd float %dotProduct21, %product24
  %column26 = extractvalue [4 x <4 x float>] %1, 3
  %element27 = extractelement <4 x float> %column26, i32 1
  %product28 = fmul float %element27, %component3
  %dotProduct29 = fadd float %dotProduct25, %product28
  %5 = insertelement <4 x float> %4, float %dotProduct29, i32 1
  %column30 = extractvalue [4 x <4 x float>] %1, 0
  %element31 = extractelement <4 x float> %column30, i32 2
  %product32 = fmul float %element31, %component
  %column33 = extractvalue [4 x <4 x float>] %1, 1
  %element34 = extractelement <4 x float> %column33, i32 2
  %product35 = fmul float %element34, %component1
  %dotProduct36 = fadd float %product32, %product35
  %column37 = extractvalue [4 x <4 x float>] %1, 2
  %element38 = extractelement <4 x float> %column37, i32 2
  %product39 = fmul float %element38, %component2
  %dotProduct40 = fadd float %dotProduct36, %product39
  %column41 = extractvalue [4 x <4 x float>] %1, 3
  %element42 = extractelement <4 x float> %column41, i32 2
  %product43 = fmul float %element42, %component3
  %dotProduct44 = fadd float %dotProduct40, %product43
  %6 = insertelement <4 x float> %5, float %dotProduct44, i32 2
  %column45 = extractvalue [4 x <4 x float>] %1, 0
  %element46 = extractelement <4 x float> %column45, i32 3
  %product47 = fmul float %element46, %component
  %column48 = extractvalue [4 x <4 x float>] %1, 1
  %element49 = extractelement <4 x float> %column48, i32 3
  %product50 = fmul float %element49, %component1
  %dotProduct51 = fadd float %product47, %product50
  %column52 = extractvalue [4 x <4 x float>] %1, 2
  %element53 = extractelement <4 x float> %column52, i32 3
  %product54 = fmul float %element53, %component2
  %dotProduct55 = fadd float %dotProduct51, %product54
  %column56 = extractvalue [4 x <4 x float>] %1, 3
  %element57 = extractelement <4 x float> %column56, i32 3
  %product58 = fmul float %element57, %component3
  %dotProduct59 = fadd float %dotProduct55, %product58
  %glPos_shadow = insertelement <4 x float> %6, float %dotProduct59, i32 3
  store <4 x float> %glPos_shadow, <4 x float>* @glPos_shadow
  %am3 = call <3 x float> @llvm.gla.fReadData.v3f32(i32 1027, i32 -1), !gla.input !9
  store <3 x float> %am3, <3 x float>* getelementptr inbounds ([3 x <3 x float>]* @am3_shadow, i32 0, i32 0)
  %am360 = call <3 x float> @llvm.gla.fReadData.v3f32(i32 1028, i32 -1), !gla.input !9
  store <3 x float> %am360, <3 x float>* getelementptr inbounds ([3 x <3 x float>]* @am3_shadow, i32 0, i32 1)
  %am361 = call <3 x float> @llvm.gla.fReadData.v3f32(i32 1029, i32 -1), !gla.input !9
  store <3 x float> %am361, <3 x float>* getelementptr inbounds ([3 x <3 x float>]* @am3_shadow, i32 0, i32 2)
  %7 = load <3 x float>* getelementptr inbounds ([3 x <3 x float>]* @am3_shadow, i32 0, i32 2)
  %8 = extractelement <3 x float> %7, i32 1
  %arraym = call <4 x float> @llvm.gla.fReadData.v4f32(i32 1030, i32 -1), !gla.input !11
  store <4 x float> %arraym, <4 x float>* getelementptr inbounds ([3 x [4 x <4 x float>]]* @arraym_shadow, i32 0, i32 0, i32 0)
  %arraym62 = call <4 x float> @llvm.gla.fReadData.v4f32(i32 1031, i32 -1), !gla.input !11
  store <4 x float> %arraym62, <4 x float>* getelementptr inbounds ([3 x [4 x <4 x float>]]* @arraym_shadow, i32 0, i32 0, i32 1)
  %arraym63 = call <4 x float> @llvm.gla.fReadData.v4f32(i32 1032, i32 -1), !gla.input !11
  store <4 x float> %arraym63, <4 x float>* getelementptr inbounds ([3 x [4 x <4 x float>]]* @arraym_shadow, i32 0, i32 0, i32 2)
  %arraym64 = call <4 x float> @llvm.gla.fReadData.v4f32(i32 1033, i32 -1), !gla.input !11
  store <4 x float> %arraym64, <4 x float>* getelementptr inbounds ([3 x [4 x <4 x float>]]* @arraym_shadow, i32 0, i32 0, i32 3)
  %arraym65 = call <4 x float> @llvm.gla.fReadData.v4f32(i32 1034, i32 -1), !gla.input !11
  store <4 x float> %arraym65, <4 x float>* getelementptr inbounds ([3 x [4 x <4 x float>]]* @arraym_shadow, i32 0, i32 1, i32 0)
  %arraym66 = call <4 x float> @llvm.gla.fReadData.v4f32(i32 1035, i32 -1), !gla.input !11
  store <4 x float> %arraym66, <4 x float>* getelementptr inbounds ([3 x [4 x <4 x float>]]* @arraym_shadow, i32 0, i32 1, i32 1)
  %arraym67 = call <4 x float> @llvm.gla.fReadData.v4f32(i32 1036, i32 -1), !gla.input !11
  store <4 x float> %arraym67, <4 x float>* getelementptr inbounds ([3 x [4 x <4 x float>]]* @arraym_shadow, i32 0, i32 1, i32 2)
  %arraym68 = call <4 x float> @llvm.gla.fReadData.v4f32(i32 1037, i32 -1), !gla.input !11
  store <4 x float> %arraym68, <4 x float>* getelementptr inbounds ([3 x [4 x <4 x float>]]* @arraym_shadow, i32 0, i32 1, i32 3)
  %arraym69 = call <4 x float> @llvm.gla.fReadData.v4f32(i32 1038, i32 -1), !gla.input !11
  store <4 x float> %arraym69, <4 x float>* getelementptr inbounds ([3 x [4 x <4 x float>]]* @arraym_shadow, i32 0, i32 2, i32 0)
  %arraym70 = call <4 x float> @llvm.gla.fReadData.v4f32(i32 1039, i32 -1), !gla.input !11
  store <4 x float> %arraym70, <4 x float>* getelementptr inbounds ([3 x [4 x <4 x float>]]* @arraym_shadow, i32 0, i32 2, i32 1)
  %arraym71 = call <4 x float> @llvm.gla.fReadData.v4f32(i32 1040, i32 -1), !gla.input !11
  store <4 x float> %arraym71, <4 x float>* getelementptr inbounds ([3 x [4 x <4 x float>]]* @arraym_shadow, i32 0, i32 2, i32 2)
  %arraym72 = call <4 x float> @llvm.gla.fReadData.v4f32(i32 1041, i32 -1), !gla.input !11
  store <4 x float> %arraym72, <4 x float>* getelementptr inbounds ([3 x [4 x <4 x float>]]* @arraym_shadow, i32 0, i32 2, i32 3)
  %9 = load <4 x float>* getelementptr inbounds ([3 x [4 x <4 x float>]]* @arraym_shadow, i32 0, i32 1, i32 2)
  %10 = extractelement <4 x float> %9, i32 3
  %f_shadow = fadd float %8, %10
  store float %f_shadow, float* @f_shadow
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %entry
  %11 = load <4 x float>* @glPos_shadow
  call void @llvm.gla.fWriteData.v4f32(i32 1024, i32 -1, <4 x float> %11), !gla.output !1
  %12 = load float* @f_shadow
  call void @llvm.gla.fWriteData.f32(i32 1026, i32 -1, float %12), !gla.output !3
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.gla.fReadData.v4f32(i32, i32) #0

; Function Attrs: nounwind readonly
declare <3 x float> @llvm.gla.fReadData.v3f32(i32, i32) #0

; Function Attrs: nounwind
declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) #1

; Function Attrs: nounwind
declare void @llvm.gla.fWriteData.f32(i32, i32, float) #1

attributes #0 = { nounwind readonly }
attributes #1 = { nounwind }

!gla.entrypoint = !{!0}
!gla.outputs = !{!1, !3}
!gla.uniforms = !{!5}
!gla.inputs = !{!7, !9, !11, !13, !15}
!gla.noStaticUse = !{!13, !15}

!0 = metadata !{metadata !"main", i32 15}
!1 = metadata !{metadata !"glPos", i32 7, <4 x float>* @glPos_shadow_typeProxy, metadata !2}
!2 = metadata !{i32 0, i32 0, i32 1024, null, i32 1}
!3 = metadata !{metadata !"f", i32 7, float* @f_shadow_typeProxy, metadata !4}
!4 = metadata !{i32 0, i32 0, i32 1026, null, i32 1}
!5 = metadata !{metadata !"mvp", i32 12, [4 x <4 x float>]* @mvp_typeProxy, metadata !6}
!6 = metadata !{i32 3, i32 0, i32 1024, null}
!7 = metadata !{metadata !"v", i32 1, <4 x float>* @v_shadow_typeProxy, metadata !8}
!8 = metadata !{i32 0, i32 0, i32 1025, null, i32 0}
!9 = metadata !{metadata !"am3", i32 1, [3 x <3 x float>]* @am3_shadow_typeProxy, metadata !10}
!10 = metadata !{i32 3, i32 0, i32 1027, null, i32 0}
!11 = metadata !{metadata !"arraym", i32 1, [3 x [4 x <4 x float>]]* @arraym_shadow_typeProxy, metadata !12}
!12 = metadata !{i32 3, i32 0, i32 1030, null, i32 0}
!13 = metadata !{metadata !"gl_VertexID", i32 2, i32* @VertexID_shadow_typeProxy, metadata !14}
!14 = metadata !{i32 0, i32 0, i32 1042, null, i32 0}
!15 = metadata !{metadata !"gl_InstanceID", i32 3, i32* @InstanceID_shadow_typeProxy, metadata !16}
!16 = metadata !{i32 0, i32 0, i32 1043, null, i32 0}


Bottom IR:
; ModuleID = 'Glslang'

@mvp = external addrspace(2) constant [4 x <4 x float>]

define fastcc void @main() {
entry:
  %0 = load [4 x <4 x float>] addrspace(2)* @mvp, align 16, !gla.uniform !5
  %v = call <4 x float> @llvm.gla.fReadData.v4f32(i32 1025, i32 -1), !gla.input !7
  %component = extractelement <4 x float> %v, i32 0
  %component1 = extractelement <4 x float> %v, i32 1
  %component2 = extractelement <4 x float> %v, i32 2
  %component3 = extractelement <4 x float> %v, i32 3
  %am361 = call <3 x float> @llvm.gla.fReadData.v3f32(i32 1029, i32 -1), !gla.input !9
  %arraym67 = call <4 x float> @llvm.gla.fReadData.v4f32(i32 1036, i32 -1), !gla.input !11
  %column4 = extractvalue [4 x <4 x float>] %0, 1
  %column = extractvalue [4 x <4 x float>] %0, 0
  %column7 = extractvalue [4 x <4 x float>] %0, 2
  %element5 = extractelement <4 x float> %column4, i32 0
  %element = extractelement <4 x float> %column, i32 0
  %element19 = extractelement <4 x float> %column4, i32 1
  %element16 = extractelement <4 x float> %column, i32 1
  %column11 = extractvalue [4 x <4 x float>] %0, 3
  %element8 = extractelement <4 x float> %column7, i32 0
  %product6 = fmul float %element5, %component1
  %product = fmul float %element, %component
  %element34 = extractelement <4 x float> %column4, i32 2
  %element31 = extractelement <4 x float> %column, i32 2
  %element23 = extractelement <4 x float> %column7, i32 1
  %product20 = fmul float %element19, %component1
  %product17 = fmul float %element16, %component
  %element12 = extractelement <4 x float> %column11, i32 0
  %product9 = fmul float %element8, %component2
  %dotProduct = fadd float %product, %product6
  %element49 = extractelement <4 x float> %column4, i32 3
  %element46 = extractelement <4 x float> %column, i32 3
  %element38 = extractelement <4 x float> %column7, i32 2
  %product35 = fmul float %element34, %component1
  %product32 = fmul float %element31, %component
  %element27 = extractelement <4 x float> %column11, i32 1
  %product24 = fmul float %element23, %component2
  %dotProduct21 = fadd float %product17, %product20
  %product13 = fmul float %element12, %component3
  %dotProduct10 = fadd float %product9, %dotProduct
  %element53 = extractelement <4 x float> %column7, i32 3
  %product50 = fmul float %element49, %component1
  %product47 = fmul float %element46, %component
  %element42 = extractelement <4 x float> %column11, i32 2
  %product39 = fmul float %element38, %component2
  %dotProduct36 = fadd float %product32, %product35
  %product28 = fmul float %element27, %component3
  %dotProduct25 = fadd float %product24, %dotProduct21
  %dotProduct14 = fadd float %product13, %dotProduct10
  %element57 = extractelement <4 x float> %column11, i32 3
  %product54 = fmul float %element53, %component2
  %dotProduct51 = fadd float %product47, %product50
  %product43 = fmul float %element42, %component3
  %dotProduct40 = fadd float %product39, %dotProduct36
  %dotProduct29 = fadd float %product28, %dotProduct25
  %product58 = fmul float %element57, %component3
  %dotProduct55 = fadd float %product54, %dotProduct51
  %dotProduct44 = fadd float %product43, %dotProduct40
  %1 = extractelement <4 x float> %arraym67, i32 3
  %2 = extractelement <3 x float> %am361, i32 1
  %dotProduct59 = fadd float %product58, %dotProduct55
  %f_shadow = fadd float %2, %1
  %3 = call <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.f32.f32.f32.f32(<4 x float> undef, i32 15, float %dotProduct14, i32 0, float %dotProduct29, i32 0, float %dotProduct44, i32 0, float %dotProduct59, i32 0)
  call void @llvm.gla.fWriteData.v4f32(i32 1024, i32 -1, <4 x float> %3), !gla.output !1
  call void @llvm.gla.fWriteData.f32(i32 1026, i32 -1, float %f_shadow), !gla.output !3
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %entry
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.gla.fReadData.v4f32(i32, i32) #0

; Function Attrs: nounwind readonly
declare <3 x float> @llvm.gla.fReadData.v3f32(i32, i32) #0

; Function Attrs: nounwind
declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) #1

; Function Attrs: nounwind
declare void @llvm.gla.fWriteData.f32(i32, i32, float) #1

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.f32.f32.f32.f32(<4 x float>, i32, float, i32, float, i32, float, i32, float, i32) #2

attributes #0 = { nounwind readonly }
attributes #1 = { nounwind }
attributes #2 = { nounwind readnone }

!gla.entrypoint = !{!0}
!gla.outputs = !{!1, !3}
!gla.uniforms = !{!5}
!gla.inputs = !{!7, !9, !11, !13, !15}
!gla.noStaticUse = !{!13, !15}

!0 = metadata !{metadata !"main", i32 15}
!1 = metadata !{metadata !"glPos", i32 7, <4 x float>* @glPos_shadow_typeProxy, metadata !2}
!2 = metadata !{i32 0, i32 0, i32 1024, null, i32 1}
!3 = metadata !{metadata !"f", i32 7, float* @f_shadow_typeProxy, metadata !4}
!4 = metadata !{i32 0, i32 0, i32 1026, null, i32 1}
!5 = metadata !{metadata !"mvp", i32 12, [4 x <4 x float>]* @mvp_typeProxy, metadata !6}
!6 = metadata !{i32 3, i32 0, i32 1024, null}
!7 = metadata !{metadata !"v", i32 1, <4 x float>* @v_shadow_typeProxy, metadata !8}
!8 = metadata !{i32 0, i32 0, i32 1025, null, i32 0}
!9 = metadata !{metadata !"am3", i32 1, [3 x <3 x float>]* @am3_shadow_typeProxy, metadata !10}
!10 = metadata !{i32 3, i32 0, i32 1027, null, i32 0}
!11 = metadata !{metadata !"arraym", i32 1, [3 x [4 x <4 x float>]]* @arraym_shadow_typeProxy, metadata !12}
!12 = metadata !{i32 3, i32 0, i32 1030, null, i32 0}
!13 = metadata !{metadata !"gl_VertexID", i32 2, i32* @VertexID_shadow_typeProxy, metadata !14}
!14 = metadata !{i32 0, i32 0, i32 1042, null, i32 0}
!15 = metadata !{metadata !"gl_InstanceID", i32 3, i32* @InstanceID_shadow_typeProxy, metadata !16}
!16 = metadata !{i32 0, i32 0, i32 1043, null, i32 0}
#version 330 core
// LunarGOO output
uniform mat4 mvp;
in vec4 v;
in mat3 am3;
in mat4 arraym[3];
out vec4 glPos;
out float f;

void main()
{
    vec4 column_c1 = mvp[1];
    vec4 column_c2 = mvp[0];
    vec4 column_c3 = mvp[2];
    vec4 column_c4 = mvp[3];
    float product_c5 = column_c1.x * v.y;
    float product_c6 = column_c2.x * v.x;
    float product_c7 = column_c1.y * v.y;
    float product_c8 = column_c2.y * v.x;
    float product_c9 = column_c3.x * v.z;
    float dotProduct_c10 = product_c5 + product_c6;
    float product_c11 = column_c1.z * v.y;
    float product_c12 = column_c2.z * v.x;
    float product_c13 = column_c3.y * v.z;
    float dotProduct_c14 = product_c7 + product_c8;
    float product_c15 = column_c4.x * v.w;
    float dotProduct_c16 = dotProduct_c10 + product_c9;
    float product_c17 = column_c1.w * v.y;
    float product_c18 = column_c2.w * v.x;
    float product_c19 = column_c3.z * v.z;
    float dotProduct_c20 = product_c11 + product_c12;
    float product_c21 = column_c4.y * v.w;
    float dotProduct_c22 = dotProduct_c14 + product_c13;
    float dotProduct_c23 = dotProduct_c16 + product_c15;
    float product_c24 = column_c3.w * v.z;
    float dotProduct_c25 = product_c17 + product_c18;
    float product_c26 = column_c4.z * v.w;
    float dotProduct_c27 = dotProduct_c20 + product_c19;
    float dotProduct_c28 = dotProduct_c22 + product_c21;
    float product_c29 = column_c4.w * v.w;
    float dotProduct_c30 = dotProduct_c25 + product_c24;
    float dotProduct_c31 = dotProduct_c27 + product_c26;
    float dotProduct_c32 = dotProduct_c30 + product_c29;
    float f_shadow_c33 = am3[2].y + arraym[1][2].w;
    vec4 temp54 = vec4(dotProduct_c23, dotProduct_c28, dotProduct_c31, dotProduct_c32);
    glPos = temp54;
    f = f_shadow_c33;
    
}


#version 330 core
// LunarGOO output
uniform mat4 mvp;
in vec4 v;
in mat3 am3;
in mat4 arraym[3];
out vec4 glPos;
out float f;

void main()
{
    float product_c1 = mvp[0].x * v.x;
    float product_c2 = mvp[1].x * v.y;
    float dotProduct_c3 = product_c1 + product_c2;
    float product_c4 = mvp[2].x * v.z;
    float product_c5 = mvp[0].y * v.x;
    float product_c6 = mvp[1].y * v.y;
    float dotProduct_c7 = dotProduct_c3 + product_c4;
    float product_c8 = mvp[3].x * v.w;
    float dotProduct_c9 = product_c5 + product_c6;
    float product_c10 = mvp[2].y * v.z;
    float product_c11 = mvp[0].z * v.x;
    float product_c12 = mvp[1].z * v.y;
    float dotProduct_c13 = dotProduct_c7 + product_c8;
    float dotProduct_c14 = dotProduct_c9 + product_c10;
    float product_c15 = mvp[3].y * v.w;
    float dotProduct_c16 = product_c11 + product_c12;
    float product_c17 = mvp[2].z * v.z;
    float product_c18 = mvp[0].w * v.x;
    float product_c19 = mvp[1].w * v.y;
    float dotProduct_c20 = dotProduct_c14 + product_c15;
    float dotProduct_c21 = dotProduct_c16 + product_c17;
    float product_c22 = mvp[3].z * v.w;
    float dotProduct_c23 = product_c18 + product_c19;
    float product_c24 = mvp[2].w * v.z;
    float dotProduct_c25 = dotProduct_c21 + product_c22;
    float dotProduct_c26 = dotProduct_c23 + product_c24;
    float product_c27 = mvp[3].w * v.w;
    float dotProduct_c28 = dotProduct_c26 + product_c27;
    vec4 temp49 = vec4(dotProduct_c13, dotProduct_c20, dotProduct_c25, dotProduct_c28);
    float f_shadow_c29 = am3[2].y + arraym[1][2].w;
    glPos = temp49;
    f = f_shadow_c29;
    
}


