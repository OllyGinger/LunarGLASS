
Top IR:
; ModuleID = 'Glslang'

@outp_shadow = internal global <4 x float> zeroinitializer
@u2drs = external addrspace(1) constant i32
@arrayedSampler = external addrspace(1) constant [5 x i32]
@i_shadow = internal global i32 0
@c2D_shadow = internal global <2 x float> zeroinitializer
@ClipDistance_shadow = internal global [2 x float] zeroinitializer
@uoutp_shadow = internal global <4 x i32> zeroinitializer
@samp2dr = external addrspace(1) constant i32
@ioutp_shadow = internal global <4 x i32> zeroinitializer
@isamp2DA = external addrspace(1) constant i32
@FragCoord_shadow = internal global <4 x float> zeroinitializer
@vl2_shadow = internal global <4 x float> zeroinitializer

define fastcc void @main() {
entry:
  %constructed = alloca <2 x i32>
  %v = alloca <4 x float>
  %i = call i32 @llvm.gla.readData.i32(i32 1025, i32 -1), !gla.input !19
  store i32 %i, i32* @i_shadow
  %0 = load i32* @i_shadow
  %1 = getelementptr [5 x i32] addrspace(1)* @arrayedSampler, i32 0, i32 %0
  %2 = load i32 addrspace(1)* %1, !gla.uniform !9
  %c2D = call <2 x float> @llvm.gla.fReadInterpolant.v2f32(i32 1026, i32 -1, i32 1), !gla.input !21
  store <2 x float> %c2D, <2 x float>* @c2D_shadow
  %3 = load <2 x float>* @c2D_shadow
  %v1 = call <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32 2, i32 %2, i32 0, <2 x float> %3)
  store <4 x float> %v1, <4 x float>* %v
  %gl_ClipDistance = call float @llvm.gla.fReadInterpolant.f32(i32 1027, i32 -1, i32 1), !gla.input !23
  store float %gl_ClipDistance, float* getelementptr inbounds ([2 x float]* @ClipDistance_shadow, i32 0, i32 0)
  %gl_ClipDistance2 = call float @llvm.gla.fReadInterpolant.f32(i32 1028, i32 -1, i32 1), !gla.input !23
  store float %gl_ClipDistance2, float* getelementptr inbounds ([2 x float]* @ClipDistance_shadow, i32 0, i32 1)
  %4 = load float* getelementptr inbounds ([2 x float]* @ClipDistance_shadow, i32 0, i32 1)
  %5 = load <4 x float>* @outp_shadow
  %outp_shadow = insertelement <4 x float> %5, float %4, i32 0
  store <4 x float> %outp_shadow, <4 x float>* @outp_shadow
  %6 = load <4 x float>* %v
  %7 = extractelement <4 x float> %6, i32 1
  %8 = insertelement <3 x float> undef, float %7, i32 0
  %9 = extractelement <4 x float> %6, i32 2
  %10 = insertelement <3 x float> %8, float %9, i32 1
  %11 = extractelement <4 x float> %6, i32 3
  %12 = insertelement <3 x float> %10, float %11, i32 2
  %13 = load <4 x float>* @outp_shadow
  %14 = extractelement <3 x float> %12, i32 0
  %15 = insertelement <4 x float> %13, float %14, i32 1
  %16 = extractelement <3 x float> %12, i32 1
  %17 = insertelement <4 x float> %15, float %16, i32 2
  %18 = extractelement <3 x float> %12, i32 2
  %outp_shadow3 = insertelement <4 x float> %17, float %18, i32 3
  store <4 x float> %outp_shadow3, <4 x float>* @outp_shadow
  %19 = load i32 addrspace(1)* @samp2dr, !gla.uniform !12
  %c2D4 = call <2 x float> @llvm.gla.fReadInterpolant.v2f32(i32 1026, i32 -1, i32 1), !gla.input !21
  store <2 x float> %c2D4, <2 x float>* @c2D_shadow
  %20 = load <2 x float>* @c2D_shadow
  %uoutp_shadow = call <4 x i32> @llvm.gla.textureSampleLodRefZOffset.v4i32.v2f32.ch(i32 5, i32 %19, i32 386, <2 x float> %20, i32 2, float undef, [4 x <2 x i32>] [<2 x i32> <i32 1, i32 2>, <2 x i32> <i32 3, i32 4>, <2 x i32> <i32 15, i32 16>, <2 x i32> <i32 -2, i32 0>])
  store <4 x i32> %uoutp_shadow, <4 x i32>* @uoutp_shadow
  %21 = load i32 addrspace(1)* getelementptr inbounds ([5 x i32] addrspace(1)* @arrayedSampler, i32 0, i32 0), !gla.uniform !9
  %c2D5 = call <2 x float> @llvm.gla.fReadInterpolant.v2f32(i32 1026, i32 -1, i32 1), !gla.input !21
  store <2 x float> %c2D5, <2 x float>* @c2D_shadow
  %22 = load <2 x float>* @c2D_shadow
  %23 = call <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32 2, i32 %21, i32 0, <2 x float> %22)
  %24 = load <4 x float>* @outp_shadow
  %outp_shadow6 = fadd <4 x float> %24, %23
  store <4 x float> %outp_shadow6, <4 x float>* @outp_shadow
  %25 = load i32 addrspace(1)* @isamp2DA, !gla.uniform !15
  %ioutp_shadow = call <4 x i32> @llvm.gla.textureSampleLodRefZOffset.v4i32.v3f32.v2i32(i32 2, i32 %25, i32 402, <3 x float> <float 0x3FB99999A0000000, float 0x3FB99999A0000000, float 0x3FB99999A0000000>, i32 3, float undef, <2 x i32> <i32 1, i32 1>)
  store <4 x i32> %ioutp_shadow, <4 x i32>* @ioutp_shadow
  %26 = load i32 addrspace(1)* @isamp2DA, !gla.uniform !15
  %27 = call <4 x i32> @llvm.gla.textureSampleLodRefZOffset.v4i32.v3f32.v2i32(i32 2, i32 %26, i32 402, <3 x float> <float 0x3FB99999A0000000, float 0x3FB99999A0000000, float 0x3FB99999A0000000>, i32 3, float undef, <2 x i32> <i32 1, i32 1>)
  %28 = load <4 x i32>* @ioutp_shadow
  %ioutp_shadow7 = add <4 x i32> %28, %27
  store <4 x i32> %ioutp_shadow7, <4 x i32>* @ioutp_shadow
  %29 = load i32 addrspace(1)* @isamp2DA, !gla.uniform !15
  %i8 = call i32 @llvm.gla.readData.i32(i32 1025, i32 -1), !gla.input !19
  store i32 %i8, i32* @i_shadow
  %30 = load i32* @i_shadow
  %31 = load <2 x i32>* %constructed
  %32 = insertelement <2 x i32> undef, i32 %30, i32 0
  %33 = insertelement <2 x i32> %32, i32 %30, i32 1
  %34 = call <4 x i32> @llvm.gla.textureSampleLodRefZOffset.v4i32.v3f32.v2i32(i32 2, i32 %29, i32 272, <3 x float> <float 0x3FB99999A0000000, float 0x3FB99999A0000000, float 0x3FB99999A0000000>, float undef, float undef, <2 x i32> %33)
  %35 = load <4 x i32>* @ioutp_shadow
  %ioutp_shadow9 = add <4 x i32> %35, %34
  store <4 x i32> %ioutp_shadow9, <4 x i32>* @ioutp_shadow
  %gl_FragCoord = call <4 x float> @llvm.gla.fReadData.v4f32(i32 1031, i32 -1), !gla.input !25
  store <4 x float> %gl_FragCoord, <4 x float>* @FragCoord_shadow
  %36 = load <4 x float>* @FragCoord_shadow
  %vl2 = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 6, i32 -1, i32 1), !gla.input !27
  store <4 x float> %vl2, <4 x float>* @vl2_shadow
  %37 = load <4 x float>* @vl2_shadow
  %38 = fadd <4 x float> %36, %37
  %39 = load <4 x float>* @outp_shadow
  %outp_shadow10 = fadd <4 x float> %39, %38
  store <4 x float> %outp_shadow10, <4 x float>* @outp_shadow
  call void @"foo23("()
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %entry
  %40 = load <4 x float>* @outp_shadow
  call void @llvm.gla.fWriteData.v4f32(i32 1024, i32 -1, <4 x float> %40), !gla.output !0
  %41 = load <4 x i32>* @uoutp_shadow
  call void @llvm.gla.writeData.v4i32(i32 1029, i32 -1, <4 x i32> %41), !gla.output !2
  %42 = load <4 x i32>* @ioutp_shadow
  call void @llvm.gla.writeData.v4i32(i32 1030, i32 -1, <4 x i32> %42), !gla.output !4
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: alwaysinline
define internal fastcc void @"foo23("() #0 {
entry:
  %0 = load i32 addrspace(1)* @u2drs, !gla.uniform !6
  %1 = load <4 x float>* @outp_shadow
  %2 = call float @llvm.gla.fTextureSampleLodRefZOffsetGrad.f32.v4f32.v2i32.v2f32.v2f32(i32 5, i32 %0, i32 265, <4 x float> %1, float undef, float undef, <2 x i32> <i32 3, i32 4>, <2 x float> zeroinitializer, <2 x float> zeroinitializer)
  %3 = load <4 x float>* @outp_shadow
  %4 = extractelement <4 x float> %3, i32 0
  %5 = fadd float %4, %2
  %6 = load <4 x float>* @outp_shadow
  %outp_shadow = insertelement <4 x float> %6, float %5, i32 0
  store <4 x float> %outp_shadow, <4 x float>* @outp_shadow
  ret void
}

; Function Attrs: nounwind readnone
declare float @llvm.gla.fTextureSampleLodRefZOffsetGrad.f32.v4f32.v2i32.v2f32.v2f32(i32, i32, i32, <4 x float>, float, float, <2 x i32>, <2 x float>, <2 x float>) #1

; Function Attrs: nounwind readonly
declare i32 @llvm.gla.readData.i32(i32, i32) #2

; Function Attrs: nounwind readnone
declare <2 x float> @llvm.gla.fReadInterpolant.v2f32(i32, i32, i32) #1

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32, i32, i32, <2 x float>) #1

; Function Attrs: nounwind readnone
declare float @llvm.gla.fReadInterpolant.f32(i32, i32, i32) #1

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.gla.textureSampleLodRefZOffset.v4i32.v2f32.ch(i32, i32, i32, <2 x float>, float, float, [4 x <2 x i32>]) #1

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.gla.textureSampleLodRefZOffset.v4i32.v3f32.v2i32(i32, i32, i32, <3 x float>, float, float, <2 x i32>) #1

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.gla.fReadData.v4f32(i32, i32) #2

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32, i32, i32) #1

; Function Attrs: nounwind
declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) #3

; Function Attrs: nounwind
declare void @llvm.gla.writeData.v4i32(i32, i32, <4 x i32>) #3

attributes #0 = { alwaysinline }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind readonly }
attributes #3 = { nounwind }

!gla.outputs = !{!0, !2, !4}
!gla.uniforms = !{!6, !9, !12, !15}
!gla.entrypoint = !{!18}
!gla.inputs = !{!19, !21, !23, !25, !27}

!0 = metadata !{metadata !"outp", i32 7, <4 x float>* @outp_shadow_typeProxy, metadata !1}
!1 = metadata !{i32 0, i32 0, i32 1024, null, i32 0}
!2 = metadata !{metadata !"uoutp", i32 7, <4 x i32>* @uoutp_shadow_typeProxy, metadata !3}
!3 = metadata !{i32 1, i32 0, i32 1029, null, i32 0}
!4 = metadata !{metadata !"ioutp", i32 7, <4 x i32>* @ioutp_shadow_typeProxy, metadata !5}
!5 = metadata !{i32 0, i32 0, i32 1030, null, i32 0}
!6 = metadata !{metadata !"u2drs", i32 12, i32* @u2drs_typeProxy, metadata !7}
!7 = metadata !{i32 5, i32 0, i32 1024, metadata !8}
!8 = metadata !{i32 0, i32* @u2drs_typeProxy, i32 4, i1 false, i1 true, i32 0}
!9 = metadata !{metadata !"arrayedSampler", i32 12, [5 x i32]* @arrayedSampler_typeProxy, metadata !10}
!10 = metadata !{i32 5, i32 0, i32 1024, metadata !11}
!11 = metadata !{i32 0, [5 x i32]* @arrayedSampler_typeProxy, i32 1, i1 false, i1 false, i32 0}
!12 = metadata !{metadata !"samp2dr", i32 12, i32* @samp2dr_typeProxy, metadata !13}
!13 = metadata !{i32 5, i32 0, i32 1024, metadata !14}
!14 = metadata !{i32 0, i32* @samp2dr_typeProxy, i32 4, i1 false, i1 false, i32 2}
!15 = metadata !{metadata !"isamp2DA", i32 12, i32* @isamp2DA_typeProxy, metadata !16}
!16 = metadata !{i32 5, i32 0, i32 1024, metadata !17}
!17 = metadata !{i32 0, i32* @isamp2DA_typeProxy, i32 1, i1 true, i1 false, i32 1}
!18 = metadata !{metadata !"main", i32 15}
!19 = metadata !{metadata !"i", i32 1, i32* @i_shadow_typeProxy, metadata !20}
!20 = metadata !{i32 0, i32 0, i32 1025, null, i32 0}
!21 = metadata !{metadata !"c2D", i32 1, <2 x float>* @c2D_shadow_typeProxy, metadata !22}
!22 = metadata !{i32 0, i32 0, i32 1026, null, i32 1}
!23 = metadata !{metadata !"gl_ClipDistance", i32 1, [2 x float]* @ClipDistance_shadow_typeProxy, metadata !24}
!24 = metadata !{i32 0, i32 0, i32 1027, null, i32 1}
!25 = metadata !{metadata !"gl_FragCoord", i32 5, <4 x float>* @FragCoord_shadow_typeProxy, metadata !26}
!26 = metadata !{i32 0, i32 0, i32 1031, null, i32 0}
!27 = metadata !{metadata !"vl2", i32 1, <4 x float>* @vl2_shadow_typeProxy, metadata !28}
!28 = metadata !{i32 0, i32 0, i32 6, null, i32 1}


Bottom IR:
; ModuleID = 'Glslang'

@u2drs = external addrspace(1) constant i32
@arrayedSampler = external addrspace(1) constant [5 x i32]
@samp2dr = external addrspace(1) constant i32
@isamp2DA = external addrspace(1) constant i32

define fastcc void @main() {
entry:
  %i = call i32 @llvm.gla.readData.i32(i32 1025, i32 -1), !gla.input !19
  %0 = getelementptr [5 x i32] addrspace(1)* @arrayedSampler, i32 0, i32 %i
  %1 = load i32 addrspace(1)* %0, align 4, !gla.uniform !9
  %c2D = call <2 x float> @llvm.gla.fReadInterpolant.v2f32(i32 1026, i32 -1, i32 1), !gla.input !21
  %v1 = call <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32 2, i32 %1, i32 0, <2 x float> %c2D)
  %gl_ClipDistance2 = call float @llvm.gla.fReadInterpolant.f32(i32 1028, i32 -1, i32 1), !gla.input !23
  %2 = call <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.f32.v4f32.v4f32.v4f32(<4 x float> undef, i32 15, float %gl_ClipDistance2, i32 0, <4 x float> %v1, i32 1, <4 x float> %v1, i32 2, <4 x float> %v1, i32 3)
  %3 = load i32 addrspace(1)* @samp2dr, align 4, !gla.uniform !12
  %gla_constGEP = getelementptr [5 x i32] addrspace(1)* @arrayedSampler, i32 0, i32 0
  %4 = load i32 addrspace(1)* %gla_constGEP, align 4, !gla.uniform !9
  %5 = call <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32 2, i32 %4, i32 0, <2 x float> %c2D)
  %outp_shadow6 = fadd <4 x float> %2, %5
  %6 = load i32 addrspace(1)* @isamp2DA, align 4, !gla.uniform !15
  %i8 = call i32 @llvm.gla.readData.i32(i32 1025, i32 -1), !gla.input !19
  %7 = call <2 x i32> @llvm.gla.swizzle.v2i32.i32.v2i32(i32 %i8, <2 x i32> zeroinitializer)
  %gl_FragCoord = call <4 x float> @llvm.gla.fReadData.v4f32(i32 1031, i32 -1), !gla.input !25
  %vl2 = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 6, i32 -1, i32 1), !gla.input !27
  %8 = fadd <4 x float> %gl_FragCoord, %vl2
  %outp_shadow10 = fadd <4 x float> %outp_shadow6, %8
  %9 = load i32 addrspace(1)* @u2drs, align 4, !gla.uniform !6
  %10 = call float @llvm.gla.fTextureSampleLodRefZOffsetGrad.f32.v4f32.v2i32.v2f32.v2f32(i32 5, i32 %9, i32 265, <4 x float> %outp_shadow10, float undef, float undef, <2 x i32> <i32 3, i32 4>, <2 x float> zeroinitializer, <2 x float> zeroinitializer)
  %11 = extractelement <4 x float> %outp_shadow10, i32 0
  %12 = fadd float %10, %11
  %13 = call <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.f32.f32.f32.f32(<4 x float> %outp_shadow10, i32 1, float %12, i32 0, float undef, i32 undef, float undef, i32 undef, float undef, i32 undef)
  %14 = call <4 x i32> @llvm.gla.textureSampleLodRefZOffset.v4i32.v3f32.v2i32(i32 2, i32 %6, i32 402, <3 x float> <float 0x3FB99999A0000000, float 0x3FB99999A0000000, float 0x3FB99999A0000000>, i32 3, float undef, <2 x i32> <i32 1, i32 1>)
  %15 = call <4 x i32> @llvm.gla.textureSampleLodRefZOffset.v4i32.v3f32.v2i32(i32 2, i32 %6, i32 272, <3 x float> <float 0x3FB99999A0000000, float 0x3FB99999A0000000, float 0x3FB99999A0000000>, float undef, float undef, <2 x i32> %7)
  %ioutp_shadow7 = shl <4 x i32> %14, <i32 1, i32 1, i32 1, i32 1>
  %ioutp_shadow9 = add <4 x i32> %ioutp_shadow7, %15
  %uoutp_shadow = call <4 x i32> @llvm.gla.textureSampleLodRefZOffset.v4i32.v2f32.ch(i32 5, i32 %3, i32 386, <2 x float> %c2D, i32 2, float undef, [4 x <2 x i32>] [<2 x i32> <i32 1, i32 2>, <2 x i32> <i32 3, i32 4>, <2 x i32> <i32 15, i32 16>, <2 x i32> <i32 -2, i32 0>])
  call void @llvm.gla.fWriteData.v4f32(i32 1024, i32 -1, <4 x float> %13), !gla.output !0
  call void @llvm.gla.writeData.v4i32(i32 1029, i32 -1, <4 x i32> %uoutp_shadow), !gla.output !2
  call void @llvm.gla.writeData.v4i32(i32 1030, i32 -1, <4 x i32> %ioutp_shadow9), !gla.output !4
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %entry
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: nounwind readnone
declare float @llvm.gla.fTextureSampleLodRefZOffsetGrad.f32.v4f32.v2i32.v2f32.v2f32(i32, i32, i32, <4 x float>, float, float, <2 x i32>, <2 x float>, <2 x float>) #0

; Function Attrs: nounwind readonly
declare i32 @llvm.gla.readData.i32(i32, i32) #1

; Function Attrs: nounwind readnone
declare <2 x float> @llvm.gla.fReadInterpolant.v2f32(i32, i32, i32) #0

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32, i32, i32, <2 x float>) #0

; Function Attrs: nounwind readnone
declare float @llvm.gla.fReadInterpolant.f32(i32, i32, i32) #0

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.gla.textureSampleLodRefZOffset.v4i32.v2f32.ch(i32, i32, i32, <2 x float>, float, float, [4 x <2 x i32>]) #0

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.gla.textureSampleLodRefZOffset.v4i32.v3f32.v2i32(i32, i32, i32, <3 x float>, float, float, <2 x i32>) #0

; Function Attrs: nounwind readonly
declare <4 x float> @llvm.gla.fReadData.v4f32(i32, i32) #1

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32, i32, i32) #0

; Function Attrs: nounwind
declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) #2

; Function Attrs: nounwind
declare void @llvm.gla.writeData.v4i32(i32, i32, <4 x i32>) #2

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.f32.f32.f32.f32(<4 x float>, i32, float, i32, float, i32, float, i32, float, i32) #0

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.f32.v4f32.v4f32.v4f32(<4 x float>, i32, float, i32, <4 x float>, i32, <4 x float>, i32, <4 x float>, i32) #0

; Function Attrs: nounwind readnone
declare <2 x i32> @llvm.gla.swizzle.v2i32.i32.v2i32(i32, <2 x i32>) #0

attributes #0 = { nounwind readnone }
attributes #1 = { nounwind readonly }
attributes #2 = { nounwind }

!gla.outputs = !{!0, !2, !4}
!gla.uniforms = !{!6, !9, !12, !15}
!gla.entrypoint = !{!18}
!gla.inputs = !{!19, !21, !23, !25, !27}

!0 = metadata !{metadata !"outp", i32 7, <4 x float>* @outp_shadow_typeProxy, metadata !1}
!1 = metadata !{i32 0, i32 0, i32 1024, null, i32 0}
!2 = metadata !{metadata !"uoutp", i32 7, <4 x i32>* @uoutp_shadow_typeProxy, metadata !3}
!3 = metadata !{i32 1, i32 0, i32 1029, null, i32 0}
!4 = metadata !{metadata !"ioutp", i32 7, <4 x i32>* @ioutp_shadow_typeProxy, metadata !5}
!5 = metadata !{i32 0, i32 0, i32 1030, null, i32 0}
!6 = metadata !{metadata !"u2drs", i32 12, i32* @u2drs_typeProxy, metadata !7}
!7 = metadata !{i32 5, i32 0, i32 1024, metadata !8}
!8 = metadata !{i32 0, i32* @u2drs_typeProxy, i32 4, i1 false, i1 true, i32 0}
!9 = metadata !{metadata !"arrayedSampler", i32 12, [5 x i32]* @arrayedSampler_typeProxy, metadata !10}
!10 = metadata !{i32 5, i32 0, i32 1024, metadata !11}
!11 = metadata !{i32 0, [5 x i32]* @arrayedSampler_typeProxy, i32 1, i1 false, i1 false, i32 0}
!12 = metadata !{metadata !"samp2dr", i32 12, i32* @samp2dr_typeProxy, metadata !13}
!13 = metadata !{i32 5, i32 0, i32 1024, metadata !14}
!14 = metadata !{i32 0, i32* @samp2dr_typeProxy, i32 4, i1 false, i1 false, i32 2}
!15 = metadata !{metadata !"isamp2DA", i32 12, i32* @isamp2DA_typeProxy, metadata !16}
!16 = metadata !{i32 5, i32 0, i32 1024, metadata !17}
!17 = metadata !{i32 0, i32* @isamp2DA_typeProxy, i32 1, i1 true, i1 false, i32 1}
!18 = metadata !{metadata !"main", i32 15}
!19 = metadata !{metadata !"i", i32 1, i32* @i_shadow_typeProxy, metadata !20}
!20 = metadata !{i32 0, i32 0, i32 1025, null, i32 0}
!21 = metadata !{metadata !"c2D", i32 1, <2 x float>* @c2D_shadow_typeProxy, metadata !22}
!22 = metadata !{i32 0, i32 0, i32 1026, null, i32 1}
!23 = metadata !{metadata !"gl_ClipDistance", i32 1, [2 x float]* @ClipDistance_shadow_typeProxy, metadata !24}
!24 = metadata !{i32 0, i32 0, i32 1027, null, i32 1}
!25 = metadata !{metadata !"gl_FragCoord", i32 5, <4 x float>* @FragCoord_shadow_typeProxy, metadata !26}
!26 = metadata !{i32 0, i32 0, i32 1031, null, i32 0}
!27 = metadata !{metadata !"vl2", i32 1, <4 x float>* @vl2_shadow_typeProxy, metadata !28}
!28 = metadata !{i32 0, i32 0, i32 6, null, i32 1}
#version 400 core
// LunarGOO output
#extension GL_ARB_separate_shader_objects : enable
uniform samplerRectShadow u2drs;
uniform sampler2D arrayedSampler;
uniform usamplerRect samp2dr;
uniform isampler2DArray isamp2DA;
flat in int i;
in vec2 c2D;
layout(location=6) in vec4 vl2;
out vec4 outp;
out uvec4 uoutp;
out ivec4 ioutp;
const vec2 const29 = vec2(0.0);
const ivec2 const30 = ivec2(3, 4);
const vec3 const34 = vec3(0.1);
const ivec2 const35 = ivec2(1);
const int const36i_3 = 3;
const ivec4 const39 = ivec4(1);
const ivec2 const42[4] = ivec2[4](ivec2(1, 2), ivec2(3, 4), ivec2(15, 16), ivec2(-2, 0));
const int const43i_2 = 2;

void main()
{
    vec4 temp21 = texture(arrayedSampler[i], c2D);
    vec4 temp22 = vec4(gl_ClipDistance[1], temp21.y, temp21.z, temp21.w);
    vec4 temp23 = texture(arrayedSampler[0], c2D);
    vec4 outp_shadow6 = temp22 + temp23;
    ivec2 temp25 = ivec2(i);
    vec4 temp26 = gl_FragCoord + vl2;
    vec4 outp_shadow10 = outp_shadow6 + temp26;
    float temp28 = textureProjGradOffset(u2drs, outp_shadow10, const29, const29, const30);
    float temp31 = temp28 + outp_shadow10.x;
    vec4 temp32 = outp_shadow10;
    temp32.x = temp31;
    ivec4 temp33 = textureOffset(isamp2DA, const34, const35, const36i_3);
    ivec4 temp37 = textureOffset(isamp2DA, const34, temp25);
    ivec4 ioutp_shadow7 = temp33 << const39;
    ivec4 ioutp_shadow9 = ioutp_shadow7 + temp37;
    ivec4 uoutp_shadow = ivec4(textureOffset(samp2dr, c2D, const42, const43i_2));
    outp = temp32;
    uoutp = uvec4(uoutp_shadow);
    ioutp = ioutp_shadow9;
    
}


tempglsl.frag
Warning, version 400 is not yet complete; some version-specific features are present, but many are missing.
ERROR: 0:4: '' :  syntax error
ERROR: 1 compilation errors.  No code generated.


