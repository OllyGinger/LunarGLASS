
Top IR:
; ModuleID = 'Glslang'

@c = external addrspace(2) constant i32
@x = global float 0.000000e+00
@d = external addrspace(2) constant i32
@color = global float 0.000000e+00
@v = external addrspace(2) constant <4 x float>

define fastcc void @main() {
entry:
  %param61 = alloca i32
  %param60 = alloca <4 x float>
  %param59 = alloca <4 x float>
  %param54 = alloca i32
  %param53 = alloca <4 x float>
  %param = alloca <4 x float>
  %j = alloca i32
  %i = alloca i32
  %f = alloca float
  %local = alloca i32
  %local1 = load i32 addrspace(2)* @c, !gla.uniform !1
  store i32 %local1, i32* %local
  %0 = load i32* %local
  %local2 = add i32 %0, 1, !gla.precision !9
  store i32 %local2, i32* %local
  %1 = load i32 addrspace(2)* @c, !gla.uniform !1
  switch i32 %1, label %switch-segment4 [
    i32 1, label %switch-segment
    i32 2, label %switch-segment3
  ]

switch-segment:                                   ; preds = %entry
  %2 = load float* @x
  %f5 = call float @llvm.gla.fSin.f32.f32(float %2), !gla.precision !9
  store float %f5, float* %f
  br label %switch-merge

switch-segment3:                                  ; preds = %entry
  %3 = load float* @x
  %f6 = call float @llvm.gla.fCos.f32.f32(float %3), !gla.precision !9
  store float %f6, float* %f
  br label %switch-merge

switch-segment4:                                  ; preds = %entry
  %4 = load float* @x
  %f7 = call float @llvm.gla.fTan.f32.f32(float %4), !gla.precision !9
  store float %f7, float* %f
  br label %switch-merge

switch-merge:                                     ; preds = %switch-segment4, %switch-segment3, %switch-segment
  %5 = load i32 addrspace(2)* @c, !gla.uniform !1
  switch i32 %5, label %switch-segment10 [
    i32 1, label %switch-segment8
    i32 2, label %switch-segment9
  ]

switch-segment8:                                  ; preds = %switch-merge
  %6 = load float* @x
  %7 = call float @llvm.gla.fSin.f32.f32(float %6), !gla.precision !9
  %8 = load float* %f
  %f12 = fadd float %8, %7, !gla.precision !9
  store float %f12, float* %f
  br label %switch-segment9

switch-segment9:                                  ; preds = %switch-segment8, %switch-merge
  %9 = load float* @x
  %10 = call float @llvm.gla.fCos.f32.f32(float %9), !gla.precision !9
  %11 = load float* %f
  %f13 = fadd float %11, %10, !gla.precision !9
  store float %f13, float* %f
  br label %switch-merge11

switch-segment10:                                 ; preds = %switch-merge
  %12 = load float* @x
  %13 = call float @llvm.gla.fTan.f32.f32(float %12), !gla.precision !9
  %14 = load float* %f
  %f14 = fadd float %14, %13, !gla.precision !9
  store float %f14, float* %f
  br label %switch-merge11

switch-merge11:                                   ; preds = %switch-segment10, %switch-segment9
  %15 = load i32 addrspace(2)* @c, !gla.uniform !1
  switch i32 %15, label %switch-merge17 [
    i32 1, label %switch-segment15
    i32 2, label %switch-segment16
  ]

switch-segment15:                                 ; preds = %switch-merge11
  %16 = load float* @x
  %17 = call float @llvm.gla.fSin.f32.f32(float %16), !gla.precision !9
  %18 = load float* %f
  %f18 = fadd float %18, %17, !gla.precision !9
  store float %f18, float* %f
  br label %switch-merge17

switch-segment16:                                 ; preds = %switch-merge11
  %19 = load float* @x
  %20 = call float @llvm.gla.fCos.f32.f32(float %19), !gla.precision !9
  %21 = load float* %f
  %f19 = fadd float %21, %20, !gla.precision !9
  store float %f19, float* %f
  br label %switch-merge17

switch-merge17:                                   ; preds = %switch-segment16, %switch-segment15, %switch-merge11
  %22 = load i32 addrspace(2)* @c, !gla.uniform !1
  switch i32 %22, label %switch-segment22 [
    i32 1, label %switch-segment20
    i32 2, label %switch-segment21
  ]

switch-segment20:                                 ; preds = %switch-merge17
  %23 = load float* @x
  %24 = call float @llvm.gla.fSin.f32.f32(float %23), !gla.precision !9
  %25 = load float* %f
  %f24 = fadd float %25, %24, !gla.precision !9
  store float %f24, float* %f
  br label %switch-merge23

switch-segment21:                                 ; preds = %switch-merge17
  %26 = load i32 addrspace(2)* @d, !gla.uniform !3
  switch i32 %26, label %switch-merge27 [
    i32 1, label %switch-segment25
    i32 2, label %switch-segment26
  ]

switch-segment22:                                 ; preds = %switch-merge17
  %27 = load float* @x
  %28 = call float @llvm.gla.fTan.f32.f32(float %27), !gla.precision !9
  %29 = load float* %f
  %f30 = fadd float %29, %28, !gla.precision !9
  store float %f30, float* %f
  br label %switch-merge23

switch-merge23:                                   ; preds = %switch-segment22, %switch-merge27, %switch-segment20
  store i32 0, i32* %i
  br label %loop-header

switch-segment25:                                 ; preds = %switch-segment21
  %30 = load float* @x
  %31 = load float* @x
  %32 = fmul float %30, %31, !gla.precision !9
  %33 = load float* @x
  %34 = fmul float %32, %33, !gla.precision !9
  %35 = load float* %f
  %f28 = fadd float %35, %34, !gla.precision !9
  store float %f28, float* %f
  br label %switch-merge27

switch-segment26:                                 ; preds = %switch-segment21
  %36 = load float* @x
  %37 = load float* @x
  %38 = fmul float %36, %37, !gla.precision !9
  %39 = load float* %f
  %f29 = fadd float %39, %38, !gla.precision !9
  store float %f29, float* %f
  br label %switch-merge27

switch-merge27:                                   ; preds = %switch-segment26, %switch-segment25, %switch-segment21
  br label %switch-merge23

loop-header:                                      ; preds = %post-loop-continue51, %ifmerge49, %switch-merge23
  %40 = load i32* %i
  %41 = icmp slt i32 %40, 10
  %42 = xor i1 %41, true
  br i1 %42, label %then, label %ifmerge

then:                                             ; preds = %loop-header
  br label %loop-merge52

post-loop-break:                                  ; No predecessors!
  br label %ifmerge

ifmerge:                                          ; preds = %loop-header, %post-loop-break
  %43 = load i32 addrspace(2)* @c, !gla.uniform !1
  switch i32 %43, label %switch-segment33 [
    i32 1, label %switch-segment31
    i32 2, label %switch-segment32
  ]

switch-segment31:                                 ; preds = %ifmerge
  %44 = load float* @x
  %45 = call float @llvm.gla.fSin.f32.f32(float %44), !gla.precision !9
  %46 = load float* %f
  %f35 = fadd float %46, %45, !gla.precision !9
  store float %f35, float* %f
  store i32 20, i32* %j
  br label %loop-header36

switch-segment32:                                 ; preds = %ifmerge
  %47 = load float* @x
  %48 = call float @llvm.gla.fCos.f32.f32(float %47), !gla.precision !9
  %49 = load float* %f
  %f45 = fadd float %49, %48, !gla.precision !9
  store float %f45, float* %f
  br label %switch-merge34

switch-segment33:                                 ; preds = %ifmerge
  %50 = load float* @x
  %51 = call float @llvm.gla.fTan.f32.f32(float %50), !gla.precision !9
  %52 = load float* %f
  %f46 = fadd float %52, %51, !gla.precision !9
  store float %f46, float* %f
  br label %switch-merge34

switch-merge34:                                   ; preds = %switch-segment33, %switch-segment32, %loop-merge
  %53 = load float* %f
  %54 = fcmp olt float %53, 0x400B70A3E0000000
  br i1 %54, label %then47, label %ifmerge49

loop-header36:                                    ; preds = %post-loop-continue, %ifmerge43, %switch-segment31
  %55 = load i32* %j
  %56 = icmp slt i32 %55, 30
  %57 = xor i1 %56, true
  br i1 %57, label %then37, label %ifmerge39

then37:                                           ; preds = %loop-header36
  br label %loop-merge

post-loop-break38:                                ; No predecessors!
  br label %ifmerge39

ifmerge39:                                        ; preds = %loop-header36, %post-loop-break38
  %58 = load float* %f
  %f40 = fadd float %58, 1.000000e+00, !gla.precision !9
  store float %f40, float* %f
  %59 = load float* %f
  %60 = fcmp olt float %59, 0x40590CCCC0000000
  br i1 %60, label %then41, label %ifmerge43

then41:                                           ; preds = %ifmerge39
  br label %loop-merge

post-loop-break42:                                ; No predecessors!
  br label %ifmerge43

ifmerge43:                                        ; preds = %ifmerge39, %post-loop-break42
  %61 = load i32* %j
  %j44 = add i32 %61, 1, !gla.precision !9
  store i32 %j44, i32* %j
  br label %loop-header36

post-loop-continue:                               ; No predecessors!
  br label %loop-header36

loop-merge:                                       ; preds = %then41, %then37
  br label %switch-merge34

then47:                                           ; preds = %switch-merge34
  br label %loop-merge52

post-loop-break48:                                ; No predecessors!
  br label %ifmerge49

ifmerge49:                                        ; preds = %switch-merge34, %post-loop-break48
  %62 = load i32* %i
  %i50 = add i32 %62, 1, !gla.precision !9
  store i32 %i50, i32* %i
  br label %loop-header

post-loop-continue51:                             ; No predecessors!
  br label %loop-header

loop-merge52:                                     ; preds = %then47, %then
  %63 = load float* %f
  %64 = load i32* %local
  %65 = sitofp i32 %64 to float, !gla.precision !9
  %color = fadd float %63, %65, !gla.precision !9
  store float %color, float* @color
  %param55 = load <4 x float> addrspace(2)* @v, !gla.uniform !4
  store <4 x float> %param55, <4 x float>* %param
  %param5356 = load <4 x float> addrspace(2)* @v, !gla.uniform !4
  store <4 x float> %param5356, <4 x float>* %param53
  %param5457 = load i32 addrspace(2)* @c, !gla.uniform !1
  store i32 %param5457, i32* %param54
  %66 = call <4 x float> @"foo1(vf4;vf4;i1;"(<4 x float>* %param, <4 x float>* %param53, i32* %param54)
  %67 = extractelement <4 x float> %66, i32 1, !gla.precision !9
  %68 = load float* @color
  %color58 = fadd float %68, %67, !gla.precision !9
  store float %color58, float* @color
  %param5962 = load <4 x float> addrspace(2)* @v, !gla.uniform !4
  store <4 x float> %param5962, <4 x float>* %param59
  %param6063 = load <4 x float> addrspace(2)* @v, !gla.uniform !4
  store <4 x float> %param6063, <4 x float>* %param60
  %param6164 = load i32 addrspace(2)* @c, !gla.uniform !1
  store i32 %param6164, i32* %param61
  %69 = call <4 x float> @"foo2(vf4;vf4;i1;"(<4 x float>* %param59, <4 x float>* %param60, i32* %param61)
  %70 = extractelement <4 x float> %69, i32 2, !gla.precision !9
  %71 = load float* @color
  %color65 = fadd float %71, %70, !gla.precision !9
  store float %color65, float* @color
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %loop-merge52
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: alwaysinline
define internal fastcc <4 x float> @"foo1(vf4;vf4;i1;"(<4 x float>*, <4 x float>*, i32*) #0 {
entry:
  %3 = load i32* %2
  switch i32 %3, label %switch-merge [
    i32 0, label %switch-segment
    i32 2, label %switch-segment1
    i32 1, label %switch-segment1
    i32 3, label %switch-segment2
  ]

switch-segment:                                   ; preds = %entry
  %4 = load <4 x float>* %0
  ret <4 x float> %4

switch-segment1:                                  ; preds = %post-return, %entry, %entry
  %5 = load <4 x float>* %1
  ret <4 x float> %5

switch-segment2:                                  ; preds = %post-return3, %entry
  %6 = load <4 x float>* %0
  %7 = load <4 x float>* %1
  %8 = fmul <4 x float> %6, %7, !gla.precision !9
  ret <4 x float> %8

switch-merge:                                     ; preds = %post-return4, %entry
  ret <4 x float> zeroinitializer

post-return:                                      ; No predecessors!
  br label %switch-segment1

post-return3:                                     ; No predecessors!
  br label %switch-segment2

post-return4:                                     ; No predecessors!
  br label %switch-merge

post-return5:                                     ; No predecessors!
  unreachable
}

; Function Attrs: alwaysinline
define internal fastcc <4 x float> @"foo2(vf4;vf4;i1;"(<4 x float>*, <4 x float>*, i32*) #0 {
entry:
  %3 = load i32* %2
  switch i32 %3, label %switch-merge [
    i32 0, label %switch-segment
    i32 2, label %switch-segment1
    i32 1, label %switch-segment2
    i32 3, label %switch-segment3
  ]

switch-segment:                                   ; preds = %entry
  %4 = load <4 x float>* %0
  ret <4 x float> %4

switch-segment1:                                  ; preds = %post-return, %entry
  ret <4 x float> <float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00>

switch-segment2:                                  ; preds = %post-return4, %entry
  %5 = load <4 x float>* %1
  ret <4 x float> %5

switch-segment3:                                  ; preds = %post-return5, %entry
  %6 = load <4 x float>* %0
  %7 = load <4 x float>* %1
  %8 = fmul <4 x float> %6, %7, !gla.precision !9
  ret <4 x float> %8

switch-merge:                                     ; preds = %post-return6, %entry
  ret <4 x float> zeroinitializer

post-return:                                      ; No predecessors!
  br label %switch-segment1

post-return4:                                     ; No predecessors!
  br label %switch-segment2

post-return5:                                     ; No predecessors!
  br label %switch-segment3

post-return6:                                     ; No predecessors!
  br label %switch-merge

post-return7:                                     ; No predecessors!
  unreachable
}

; Function Attrs: nounwind readnone
declare float @llvm.gla.fSin.f32.f32(float) #1

; Function Attrs: nounwind readnone
declare float @llvm.gla.fCos.f32.f32(float) #1

; Function Attrs: nounwind readnone
declare float @llvm.gla.fTan.f32.f32(float) #1

attributes #0 = { alwaysinline }
attributes #1 = { nounwind readnone }

!gla.entrypoint = !{!0}
!gla.uniforms = !{!1, !3, !4}
!gla.inputs = !{!5}
!gla.outputs = !{!7}

!0 = metadata !{metadata !"main", i32 15}
!1 = metadata !{metadata !"c", i32 12, i32* @c_typeProxy, metadata !2}
!2 = metadata !{i32 0, i32 2, i32 1024, null}
!3 = metadata !{metadata !"d", i32 12, i32* @d_typeProxy, metadata !2}
!4 = metadata !{metadata !"v", i32 12, <4 x float>* @v_typeProxy, metadata !2}
!5 = metadata !{metadata !"x", i32 1, float* @x_typeProxy, metadata !6}
!6 = metadata !{i32 0, i32 2, i32 1024, null, i32 1}
!7 = metadata !{metadata !"color", i32 7, float* @color_typeProxy, metadata !8}
!8 = metadata !{i32 0, i32 2, i32 1025, null, i32 0}
!9 = metadata !{i32 2}


Bottom IR:
; ModuleID = 'Glslang'

@c = external addrspace(2) constant i32
@x = global float 0.000000e+00
@d = external addrspace(2) constant i32
@color = global float 0.000000e+00
@v = external addrspace(2) constant <4 x float>

define fastcc void @main() {
entry:
  %local1 = load i32 addrspace(2)* @c, align 4, !gla.uniform !1
  %local2 = add i32 %local1, 1, !gla.precision !9
  switch i32 %local1, label %switch-segment4 [
    i32 1, label %switch-segment
    i32 2, label %switch-segment3
  ]

switch-segment:                                   ; preds = %entry
  %0 = load float* @x, align 4
  %f5 = call float @llvm.gla.fSin.f32.f32(float %0), !gla.precision !9
  br label %switch-merge

switch-segment3:                                  ; preds = %entry
  %1 = load float* @x, align 4
  %f6 = call float @llvm.gla.fCos.f32.f32(float %1), !gla.precision !9
  br label %switch-merge

switch-segment4:                                  ; preds = %entry
  %2 = load float* @x, align 4
  %f7 = call float @llvm.gla.fTan.f32.f32(float %2), !gla.precision !9
  br label %switch-merge

switch-merge:                                     ; preds = %switch-segment4, %switch-segment3, %switch-segment
  %3 = phi float [ %2, %switch-segment4 ], [ %1, %switch-segment3 ], [ %0, %switch-segment ]
  %f.0 = phi float [ %f7, %switch-segment4 ], [ %f6, %switch-segment3 ], [ %f5, %switch-segment ]
  switch i32 %local1, label %switch-segment10 [
    i32 1, label %switch-segment8
    i32 2, label %switch-segment9
  ]

switch-segment8:                                  ; preds = %switch-merge
  %4 = call float @llvm.gla.fSin.f32.f32(float %3), !gla.precision !9
  %f12 = fadd float %f.0, %4, !gla.precision !9
  br label %switch-segment9

switch-segment9:                                  ; preds = %switch-segment8, %switch-merge
  %f.1 = phi float [ %f.0, %switch-merge ], [ %f12, %switch-segment8 ]
  %5 = call float @llvm.gla.fCos.f32.f32(float %3), !gla.precision !9
  %f13 = fadd float %f.1, %5, !gla.precision !9
  br label %switch-merge11

switch-segment10:                                 ; preds = %switch-merge
  %6 = call float @llvm.gla.fTan.f32.f32(float %3), !gla.precision !9
  %f14 = fadd float %f.0, %6, !gla.precision !9
  br label %switch-merge11

switch-merge11:                                   ; preds = %switch-segment10, %switch-segment9
  %f.2 = phi float [ %f14, %switch-segment10 ], [ %f13, %switch-segment9 ]
  switch i32 %local1, label %switch-merge17 [
    i32 1, label %switch-segment15
    i32 2, label %switch-segment16
  ]

switch-segment15:                                 ; preds = %switch-merge11
  %7 = call float @llvm.gla.fSin.f32.f32(float %3), !gla.precision !9
  %f18 = fadd float %f.2, %7, !gla.precision !9
  br label %switch-merge17

switch-segment16:                                 ; preds = %switch-merge11
  %8 = call float @llvm.gla.fCos.f32.f32(float %3), !gla.precision !9
  %f19 = fadd float %f.2, %8, !gla.precision !9
  br label %switch-merge17

switch-merge17:                                   ; preds = %switch-segment16, %switch-segment15, %switch-merge11
  %f.3 = phi float [ %f.2, %switch-merge11 ], [ %f19, %switch-segment16 ], [ %f18, %switch-segment15 ]
  switch i32 %local1, label %switch-segment22 [
    i32 1, label %switch-segment20
    i32 2, label %switch-segment21
  ]

switch-segment20:                                 ; preds = %switch-merge17
  %9 = call float @llvm.gla.fSin.f32.f32(float %3), !gla.precision !9
  %f24 = fadd float %f.3, %9, !gla.precision !9
  br label %switch-merge23

switch-segment21:                                 ; preds = %switch-merge17
  %10 = load i32 addrspace(2)* @d, align 4, !gla.uniform !3
  switch i32 %10, label %switch-merge27 [
    i32 1, label %switch-segment25
    i32 2, label %switch-segment26
  ]

switch-segment22:                                 ; preds = %switch-merge17
  %11 = call float @llvm.gla.fTan.f32.f32(float %3), !gla.precision !9
  %f30 = fadd float %f.3, %11, !gla.precision !9
  br label %switch-merge23

switch-merge23:                                   ; preds = %switch-segment22, %switch-merge27, %switch-segment20
  %f.4 = phi float [ %f30, %switch-segment22 ], [ %f.5, %switch-merge27 ], [ %f24, %switch-segment20 ]
  %12 = call float @llvm.gla.fTan.f32.f32(float %3), !gla.precision !9
  %13 = call float @llvm.gla.fSin.f32.f32(float %3), !gla.precision !9
  %14 = call float @llvm.gla.fCos.f32.f32(float %3), !gla.precision !9
  br label %loop-header

switch-segment25:                                 ; preds = %switch-segment21
  %15 = fmul float %3, %3, !gla.precision !9
  %16 = fmul float %3, %15, !gla.precision !9
  %f28 = fadd float %f.3, %16, !gla.precision !9
  br label %switch-merge27

switch-segment26:                                 ; preds = %switch-segment21
  %17 = fmul float %3, %3, !gla.precision !9
  %f29 = fadd float %f.3, %17, !gla.precision !9
  br label %switch-merge27

switch-merge27:                                   ; preds = %switch-segment26, %switch-segment25, %switch-segment21
  %f.5 = phi float [ %f.3, %switch-segment21 ], [ %f29, %switch-segment26 ], [ %f28, %switch-segment25 ]
  br label %switch-merge23

loop-header:                                      ; preds = %switch-merge34, %switch-merge23
  %i.0 = phi i32 [ 0, %switch-merge23 ], [ %i50, %switch-merge34 ]
  %f.6 = phi float [ %f.4, %switch-merge23 ], [ %f.7, %switch-merge34 ]
  %18 = icmp sgt i32 %i.0, 9
  br i1 %18, label %then, label %ifmerge

then:                                             ; preds = %loop-header
  br label %loop-merge52

ifmerge:                                          ; preds = %loop-header
  switch i32 %local1, label %switch-segment33 [
    i32 1, label %switch-segment31
    i32 2, label %switch-segment32
  ]

switch-segment31:                                 ; preds = %ifmerge
  %f35 = fadd float %f.6, %13, !gla.precision !9
  br label %loop-header36

switch-segment32:                                 ; preds = %ifmerge
  %f45 = fadd float %f.6, %14, !gla.precision !9
  br label %switch-merge34

switch-segment33:                                 ; preds = %ifmerge
  %f46 = fadd float %f.6, %12, !gla.precision !9
  br label %switch-merge34

switch-merge34:                                   ; preds = %switch-segment33, %switch-segment32, %loop-merge
  %f.7 = phi float [ %f46, %switch-segment33 ], [ %f45, %switch-segment32 ], [ %f.9, %loop-merge ]
  %19 = fcmp olt float %f.7, 0x400B70A3E0000000
  %i50 = add i32 %i.0, 1, !gla.precision !9
  br i1 %19, label %then47, label %loop-header

loop-header36:                                    ; preds = %ifmerge39, %switch-segment31
  %j.0 = phi i32 [ 20, %switch-segment31 ], [ %j44, %ifmerge39 ]
  %f.8 = phi float [ %f35, %switch-segment31 ], [ %f40, %ifmerge39 ]
  %20 = icmp sgt i32 %j.0, 29
  br i1 %20, label %then37, label %ifmerge39

then37:                                           ; preds = %loop-header36
  br label %loop-merge

ifmerge39:                                        ; preds = %loop-header36
  %f40 = fadd float %f.8, 1.000000e+00, !gla.precision !9
  %21 = fcmp olt float %f40, 0x40590CCCC0000000
  %j44 = add i32 %j.0, 1, !gla.precision !9
  br i1 %21, label %then41, label %loop-header36

then41:                                           ; preds = %ifmerge39
  br label %loop-merge

loop-merge:                                       ; preds = %then41, %then37
  %f.9 = phi float [ %f.8, %then37 ], [ %f40, %then41 ]
  br label %switch-merge34

then47:                                           ; preds = %switch-merge34
  br label %loop-merge52

loop-merge52:                                     ; preds = %then47, %then
  %f.10 = phi float [ %f.6, %then ], [ %f.7, %then47 ]
  %22 = sitofp i32 %local2 to float, !gla.precision !9
  %color = fadd float %22, %f.10, !gla.precision !9
  store float %color, float* @color, align 4
  %param55 = load <4 x float> addrspace(2)* @v, align 16, !gla.uniform !4
  switch i32 %local1, label %switch-merge.i [
    i32 0, label %switch-segment.i
    i32 2, label %switch-segment1.i
    i32 1, label %switch-segment1.i
    i32 3, label %switch-segment2.i
  ]

switch-segment.i:                                 ; preds = %loop-merge52
  br label %"foo1(vf4;vf4;i1;.exit"

switch-segment1.i:                                ; preds = %loop-merge52, %loop-merge52
  br label %"foo1(vf4;vf4;i1;.exit"

switch-segment2.i:                                ; preds = %loop-merge52
  %23 = fmul <4 x float> %param55, %param55, !gla.precision !9
  br label %"foo1(vf4;vf4;i1;.exit"

switch-merge.i:                                   ; preds = %loop-merge52
  br label %"foo1(vf4;vf4;i1;.exit"

"foo1(vf4;vf4;i1;.exit":                          ; preds = %switch-merge.i, %switch-segment2.i, %switch-segment1.i, %switch-segment.i
  %24 = phi <4 x float> [ %param55, %switch-segment.i ], [ %param55, %switch-segment1.i ], [ %23, %switch-segment2.i ], [ zeroinitializer, %switch-merge.i ]
  %25 = extractelement <4 x float> %24, i32 1, !gla.precision !9
  %color58 = fadd float %color, %25, !gla.precision !9
  store float %color58, float* @color, align 4
  switch i32 %local1, label %switch-merge.i69 [
    i32 0, label %switch-segment.i66
    i32 2, label %switch-segment1.i67
    i32 1, label %switch-segment2.i68
    i32 3, label %switch-segment3.i
  ]

switch-segment.i66:                               ; preds = %"foo1(vf4;vf4;i1;.exit"
  br label %"foo2(vf4;vf4;i1;.exit"

switch-segment1.i67:                              ; preds = %"foo1(vf4;vf4;i1;.exit"
  br label %"foo2(vf4;vf4;i1;.exit"

switch-segment2.i68:                              ; preds = %"foo1(vf4;vf4;i1;.exit"
  br label %"foo2(vf4;vf4;i1;.exit"

switch-segment3.i:                                ; preds = %"foo1(vf4;vf4;i1;.exit"
  %26 = fmul <4 x float> %param55, %param55, !gla.precision !9
  br label %"foo2(vf4;vf4;i1;.exit"

switch-merge.i69:                                 ; preds = %"foo1(vf4;vf4;i1;.exit"
  br label %"foo2(vf4;vf4;i1;.exit"

"foo2(vf4;vf4;i1;.exit":                          ; preds = %switch-merge.i69, %switch-segment3.i, %switch-segment2.i68, %switch-segment1.i67, %switch-segment.i66
  %27 = phi <4 x float> [ %param55, %switch-segment.i66 ], [ <float 1.000000e+00, float 1.000000e+00, float 1.000000e+00, float 1.000000e+00>, %switch-segment1.i67 ], [ %param55, %switch-segment2.i68 ], [ %26, %switch-segment3.i ], [ zeroinitializer, %switch-merge.i69 ]
  %28 = extractelement <4 x float> %27, i32 2, !gla.precision !9
  %color65 = fadd float %color58, %28, !gla.precision !9
  store float %color65, float* @color, align 4
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %"foo2(vf4;vf4;i1;.exit"
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: nounwind readnone
declare float @llvm.gla.fSin.f32.f32(float) #0

; Function Attrs: nounwind readnone
declare float @llvm.gla.fCos.f32.f32(float) #0

; Function Attrs: nounwind readnone
declare float @llvm.gla.fTan.f32.f32(float) #0

attributes #0 = { nounwind readnone }

!gla.entrypoint = !{!0}
!gla.uniforms = !{!1, !3, !4}
!gla.inputs = !{!5}
!gla.outputs = !{!7}

!0 = metadata !{metadata !"main", i32 15}
!1 = metadata !{metadata !"c", i32 12, i32* @c_typeProxy, metadata !2}
!2 = metadata !{i32 0, i32 2, i32 1024, null}
!3 = metadata !{metadata !"d", i32 12, i32* @d_typeProxy, metadata !2}
!4 = metadata !{metadata !"v", i32 12, <4 x float>* @v_typeProxy, metadata !2}
!5 = metadata !{metadata !"x", i32 1, float* @x_typeProxy, metadata !6}
!6 = metadata !{i32 0, i32 2, i32 1024, null, i32 1}
!7 = metadata !{metadata !"color", i32 7, float* @color_typeProxy, metadata !8}
!8 = metadata !{i32 0, i32 2, i32 1025, null, i32 0}
!9 = metadata !{i32 2}

***Unsupported functionality: switch terminator

Linked fragment stage:

ERROR: Linking fragment stage: Missing entry point: Each stage requires one "void main()" entry point

