
Top IR:
; ModuleID = 'Glslang'

@t = global <2 x i32> zeroinitializer
@c = global <4 x i32> zeroinitializer
@usampler = external addrspace(1) constant i32
@tc = global <2 x float> zeroinitializer
@f = global float 0.000000e+00
@v = external addrspace(2) constant <4 x i32>
@i = external addrspace(2) constant i32
@b = external addrspace(2) constant i1

define fastcc void @main() {
entry:
  %constructed57 = alloca <4 x i32>
  %mask4 = alloca i32
  %mask3 = alloca i32
  %mask2 = alloca i32
  %mask1 = alloca i32
  %constructed = alloca <4 x i32>
  %ai = alloca i32
  %ab = alloca i1
  %af = alloca float
  %shifteduu = alloca i32
  %shiftediu = alloca i32
  %shiftedui = alloca i32
  %shiftedii = alloca i32
  %u = alloca i32
  %count = alloca i32
  store i32 1, i32* %count
  %0 = load <2 x i32>* @t
  %1 = extractelement <2 x i32> %0, i32 1, !gla.precision !18
  %u1 = add i32 %1, 3, !gla.precision !18
  store i32 %u1, i32* %u
  br i1 true, label %then, label %ifmerge

then:                                             ; preds = %entry
  %2 = load i32* %count
  %count2 = mul i32 %2, 2, !gla.precision !18
  store i32 %count2, i32* %count
  br label %ifmerge

ifmerge:                                          ; preds = %entry, %then
  br i1 true, label %then3, label %ifmerge5

then3:                                            ; preds = %ifmerge
  %3 = load i32* %count
  %count4 = mul i32 %3, 3, !gla.precision !18
  store i32 %count4, i32* %count
  br label %ifmerge5

ifmerge5:                                         ; preds = %ifmerge, %then3
  br i1 false, label %then6, label %ifmerge8

then6:                                            ; preds = %ifmerge5
  %4 = load i32* %count
  %count7 = mul i32 %4, 5, !gla.precision !18
  store i32 %count7, i32* %count
  br label %ifmerge8

ifmerge8:                                         ; preds = %ifmerge5, %then6
  br i1 true, label %then9, label %ifmerge11

then9:                                            ; preds = %ifmerge8
  %5 = load i32* %count
  %count10 = mul i32 %5, 7, !gla.precision !18
  store i32 %count10, i32* %count
  br label %ifmerge11

ifmerge11:                                        ; preds = %ifmerge8, %then9
  br i1 true, label %then12, label %ifmerge14

then12:                                           ; preds = %ifmerge11
  %6 = load i32* %count
  %count13 = mul i32 %6, 11, !gla.precision !18
  store i32 %count13, i32* %count
  br label %ifmerge14

ifmerge14:                                        ; preds = %ifmerge11, %then12
  br i1 false, label %then15, label %ifmerge17

then15:                                           ; preds = %ifmerge14
  %7 = load i32* %count
  %count16 = mul i32 %7, 13, !gla.precision !18
  store i32 %count16, i32* %count
  br label %ifmerge17

ifmerge17:                                        ; preds = %ifmerge14, %then15
  store i32 -1, i32* %shiftedii
  store i32 4194303, i32* %shiftedui
  store i32 -1, i32* %shiftediu
  store i32 4194303, i32* %shifteduu
  %8 = load i32* %shiftedii
  %9 = load i32* %shiftediu
  %10 = icmp eq i32 %8, %9
  br i1 %10, label %then18, label %ifmerge19

then18:                                           ; preds = %ifmerge17
  %11 = load i32 addrspace(1)* @usampler, !gla.uniform !9
  %12 = load <2 x float>* @tc
  %c = call <4 x i32> @llvm.gla.textureSample.v4i32.v2f32(i32 2, i32 %11, i32 0, <2 x float> %12), !gla.precision !18
  store <4 x i32> %c, <4 x i32>* @c
  br label %ifmerge19

ifmerge19:                                        ; preds = %ifmerge17, %then18
  %13 = load i32* %shiftedui
  %14 = load i32* %shifteduu
  %15 = icmp eq i32 %13, %14
  br i1 %15, label %then20, label %ifmerge22

then20:                                           ; preds = %ifmerge19
  %16 = load i32 addrspace(1)* @usampler, !gla.uniform !9
  %17 = load <2 x float>* @tc
  %18 = fadd <2 x float> %17, <float 1.000000e+00, float 1.000000e+00>, !gla.precision !18
  %c21 = call <4 x i32> @llvm.gla.textureSample.v4i32.v2f32(i32 2, i32 %16, i32 0, <2 x float> %18), !gla.precision !18
  store <4 x i32> %c21, <4 x i32>* @c
  br label %ifmerge22

ifmerge22:                                        ; preds = %ifmerge19, %then20
  %19 = load i32* %shiftedii
  %20 = load i32* %shiftedui
  %21 = icmp eq i32 %19, %20
  br i1 %21, label %then23, label %ifmerge25

then23:                                           ; preds = %ifmerge22
  %22 = load i32 addrspace(1)* @usampler, !gla.uniform !9
  %23 = load <2 x float>* @tc
  %24 = fsub <2 x float> %23, <float 2.000000e+00, float 2.000000e+00>, !gla.precision !18
  %c24 = call <4 x i32> @llvm.gla.textureSample.v4i32.v2f32(i32 2, i32 %22, i32 0, <2 x float> %24), !gla.precision !18
  store <4 x i32> %c24, <4 x i32>* @c
  br label %ifmerge25

ifmerge25:                                        ; preds = %ifmerge22, %then23
  %25 = load <2 x i32>* @t
  %26 = extractelement <2 x i32> %25, i32 0, !gla.precision !18
  %27 = icmp sgt i32 %26, 4
  br i1 %27, label %then26, label %ifmerge31

then26:                                           ; preds = %ifmerge25
  %28 = load i32* %u
  %af27 = uitofp i32 %28 to float, !gla.precision !18
  store float %af27, float* %af
  %29 = load i32* %u
  %ab28 = icmp ne i32 %29, 0
  store i1 %ab28, i1* %ab
  %ai29 = load i32* %u
  store i32 %ai29, i32* %ai
  %30 = load float* %af
  %31 = fptoui float %30 to i32, !gla.precision !18
  %32 = load i1* %ab
  %33 = zext i1 %32 to i32, !gla.precision !18
  %34 = load i32* %ai
  %35 = load i32* %count
  %36 = load <4 x i32>* %constructed
  %37 = insertelement <4 x i32> %36, i32 %31, i32 0, !gla.precision !18
  %38 = insertelement <4 x i32> %37, i32 %33, i32 1, !gla.precision !18
  %39 = insertelement <4 x i32> %38, i32 %34, i32 2, !gla.precision !18
  %40 = insertelement <4 x i32> %39, i32 %35, i32 3, !gla.precision !18
  %41 = load <4 x i32>* @c
  %c30 = add <4 x i32> %41, %40, !gla.precision !18
  store <4 x i32> %c30, <4 x i32>* @c
  br label %ifmerge31

ifmerge31:                                        ; preds = %ifmerge25, %then26
  br i1 true, label %then32, label %ifmerge34

then32:                                           ; preds = %ifmerge31
  %42 = load i32* %count
  %count33 = mul i32 %42, 17, !gla.precision !18
  store i32 %count33, i32* %count
  br label %ifmerge34

ifmerge34:                                        ; preds = %ifmerge31, %then32
  br i1 false, label %then35, label %ifmerge37

then35:                                           ; preds = %ifmerge34
  %43 = load i32* %count
  %count36 = mul i32 %43, 19, !gla.precision !18
  store i32 %count36, i32* %count
  br label %ifmerge37

ifmerge37:                                        ; preds = %ifmerge34, %then35
  br i1 true, label %then38, label %ifmerge40

then38:                                           ; preds = %ifmerge37
  %44 = load i32* %count
  %count39 = mul i32 %44, 23, !gla.precision !18
  store i32 %count39, i32* %count
  br label %ifmerge40

ifmerge40:                                        ; preds = %ifmerge37, %then38
  br i1 true, label %then41, label %ifmerge43

then41:                                           ; preds = %ifmerge40
  %45 = load i32* %count
  %count42 = mul i32 %45, 27, !gla.precision !18
  store i32 %count42, i32* %count
  br label %ifmerge43

ifmerge43:                                        ; preds = %ifmerge40, %then41
  store i32 161, i32* %mask1
  store i32 2576, i32* %mask2
  %46 = load i32* %mask1
  %mask344 = shl i32 %46, 4, !gla.precision !18
  store i32 %mask344, i32* %mask3
  store i32 2737, i32* %mask4
  %47 = load i32* %mask3
  %48 = load i32* %mask2
  %49 = icmp eq i32 %47, %48
  br i1 %49, label %then45, label %ifmerge47

then45:                                           ; preds = %ifmerge43
  %50 = load i32* %count
  %count46 = mul i32 %50, 2, !gla.precision !18
  store i32 %count46, i32* %count
  br label %ifmerge47

ifmerge47:                                        ; preds = %ifmerge43, %then45
  %51 = load i32* %mask3
  %52 = load i32* %mask1
  %53 = and i32 %51, %52, !gla.precision !18
  %54 = icmp ne i32 %53, 0
  br i1 %54, label %then48, label %ifmerge50

then48:                                           ; preds = %ifmerge47
  %55 = load i32* %count
  %count49 = mul i32 %55, 3, !gla.precision !18
  store i32 %count49, i32* %count
  br label %ifmerge50

ifmerge50:                                        ; preds = %ifmerge47, %then48
  %56 = load i32* %mask1
  %57 = load i32* %mask3
  %58 = or i32 %56, %57, !gla.precision !18
  %59 = load i32* %mask4
  %60 = icmp eq i32 %58, %59
  br i1 %60, label %then51, label %ifmerge53

then51:                                           ; preds = %ifmerge50
  %61 = load i32* %count
  %count52 = mul i32 %61, 5, !gla.precision !18
  store i32 %count52, i32* %count
  br label %ifmerge53

ifmerge53:                                        ; preds = %ifmerge50, %then51
  %62 = load i32* %mask1
  %63 = load i32* %mask4
  %64 = xor i32 %62, %63, !gla.precision !18
  %65 = icmp eq i32 %64, 2576
  br i1 %65, label %then54, label %ifmerge56

then54:                                           ; preds = %ifmerge53
  %66 = load i32* %count
  %count55 = mul i32 %66, 7, !gla.precision !18
  store i32 %count55, i32* %count
  br label %ifmerge56

ifmerge56:                                        ; preds = %ifmerge53, %then54
  %67 = load i32* %count
  %68 = load <4 x i32>* %constructed57
  %69 = insertelement <4 x i32> undef, i32 %67, i32 0, !gla.precision !18
  %70 = insertelement <4 x i32> %69, i32 %67, i32 1, !gla.precision !18
  %71 = insertelement <4 x i32> %70, i32 %67, i32 2, !gla.precision !18
  %72 = insertelement <4 x i32> %71, i32 %67, i32 3, !gla.precision !18
  %73 = load <4 x i32>* @c
  %c58 = add <4 x i32> %73, %72, !gla.precision !18
  store <4 x i32> %c58, <4 x i32>* @c
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %ifmerge56
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.gla.textureSample.v4i32.v2f32(i32, i32, i32, <2 x float>) #0

attributes #0 = { nounwind readnone }

!gla.entrypoint = !{!0}
!gla.inputs = !{!1, !3, !5}
!gla.outputs = !{!7}
!gla.uniforms = !{!9, !12, !14, !16}
!gla.noStaticUse = !{!5, !12, !14, !16}

!0 = metadata !{metadata !"main", i32 15}
!1 = metadata !{metadata !"t", i32 1, <2 x i32>* @t_typeProxy, metadata !2}
!2 = metadata !{i32 1, i32 2, i32 1024, null, i32 0}
!3 = metadata !{metadata !"tc", i32 1, <2 x float>* @tc_typeProxy, metadata !4}
!4 = metadata !{i32 0, i32 2, i32 1026, null, i32 1}
!5 = metadata !{metadata !"f", i32 1, float* @f_typeProxy, metadata !6}
!6 = metadata !{i32 0, i32 2, i32 1027, null, i32 1}
!7 = metadata !{metadata !"c", i32 7, <4 x i32>* @c_typeProxy, metadata !8}
!8 = metadata !{i32 1, i32 2, i32 1025, null, i32 0}
!9 = metadata !{metadata !"usampler", i32 12, i32* @usampler_typeProxy, metadata !10}
!10 = metadata !{i32 5, i32 2, i32 1024, metadata !11}
!11 = metadata !{i32 0, i32* @usampler_typeProxy, i32 1, i1 false, i1 false, i32 2}
!12 = metadata !{metadata !"v", i32 12, <4 x i32>* @v_typeProxy, metadata !13}
!13 = metadata !{i32 1, i32 2, i32 1024, null}
!14 = metadata !{metadata !"i", i32 12, i32* @i_typeProxy, metadata !15}
!15 = metadata !{i32 0, i32 2, i32 1024, null}
!16 = metadata !{metadata !"b", i32 12, i1* @b_typeProxy, metadata !17}
!17 = metadata !{i32 0, i32 0, i32 1024, null}
!18 = metadata !{i32 2}


Bottom IR:
; ModuleID = 'Glslang'

@t = global <2 x i32> zeroinitializer
@c = global <4 x i32> zeroinitializer
@usampler = external addrspace(1) constant i32
@tc = global <2 x float> zeroinitializer
@f = global float 0.000000e+00

define fastcc void @main() {
entry:
  %0 = load <2 x i32>* @t, align 8
  %1 = extractelement <2 x i32> %0, i32 1, !gla.precision !18
  %u1 = add i32 %1, 3, !gla.precision !18
  %2 = load i32 addrspace(1)* @usampler, align 4, !gla.uniform !9
  %3 = load <2 x float>* @tc, align 8
  %4 = fadd <2 x float> %3, <float 1.000000e+00, float 1.000000e+00>, !gla.precision !18
  %c21 = call <4 x i32> @llvm.gla.textureSample.v4i32.v2f32(i32 2, i32 %2, i32 0, <2 x float> %4), !gla.precision !18
  %5 = extractelement <2 x i32> %0, i32 0, !gla.precision !18
  %6 = icmp sgt i32 %5, 4
  %af27 = uitofp i32 %u1 to float, !gla.precision !18
  %ab28 = icmp ne i32 %u1, 0
  %7 = fptoui float %af27 to i32, !gla.precision !18
  %8 = zext i1 %ab28 to i32, !gla.precision !18
  %9 = call <4 x i32> @llvm.gla.multiInsert.v4i32.v4i32.i32.i32.i32.i32(<4 x i32> undef, i32 15, i32 %7, i32 0, i32 %8, i32 0, i32 %u1, i32 0, i32 462, i32 0)
  %c30 = add <4 x i32> %c21, %9, !gla.precision !18
  %select = select i1 %6, <4 x i32> %c30, <4 x i32> %c21
  %c58 = add <4 x i32> %select, <i32 341413380, i32 341413380, i32 341413380, i32 341413380>, !gla.precision !18
  store <4 x i32> %c58, <4 x i32>* @c, align 16
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %entry
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.gla.textureSample.v4i32.v2f32(i32, i32, i32, <2 x float>) #0

; Function Attrs: nounwind readnone
declare <4 x i32> @llvm.gla.multiInsert.v4i32.v4i32.i32.i32.i32.i32(<4 x i32>, i32, i32, i32, i32, i32, i32, i32, i32, i32) #0

attributes #0 = { nounwind readnone }

!gla.entrypoint = !{!0}
!gla.inputs = !{!1, !3, !5}
!gla.outputs = !{!7}
!gla.uniforms = !{!9, !12, !14, !16}
!gla.noStaticUse = !{!5, !12, !14, !16}

!0 = metadata !{metadata !"main", i32 15}
!1 = metadata !{metadata !"t", i32 1, <2 x i32>* @t_typeProxy, metadata !2}
!2 = metadata !{i32 1, i32 2, i32 1024, null, i32 0}
!3 = metadata !{metadata !"tc", i32 1, <2 x float>* @tc_typeProxy, metadata !4}
!4 = metadata !{i32 0, i32 2, i32 1026, null, i32 1}
!5 = metadata !{metadata !"f", i32 1, float* @f_typeProxy, metadata !6}
!6 = metadata !{i32 0, i32 2, i32 1027, null, i32 1}
!7 = metadata !{metadata !"c", i32 7, <4 x i32>* @c_typeProxy, metadata !8}
!8 = metadata !{i32 1, i32 2, i32 1025, null, i32 0}
!9 = metadata !{metadata !"usampler", i32 12, i32* @usampler_typeProxy, metadata !10}
!10 = metadata !{i32 5, i32 2, i32 1024, metadata !11}
!11 = metadata !{i32 0, i32* @usampler_typeProxy, i32 1, i1 false, i1 false, i32 2}
!12 = metadata !{metadata !"v", i32 12, <4 x i32>* @v_typeProxy, metadata !13}
!13 = metadata !{i32 1, i32 2, i32 1024, null}
!14 = metadata !{metadata !"i", i32 12, i32* @i_typeProxy, metadata !15}
!15 = metadata !{i32 0, i32 2, i32 1024, null}
!16 = metadata !{metadata !"b", i32 12, i1* @b_typeProxy, metadata !17}
!17 = metadata !{i32 0, i32 0, i32 1024, null}
!18 = metadata !{i32 2}
#version 300 es
// LunarGOO output
precision mediump float; // this will be almost entirely overridden by individual declarations
uniform mediump usampler2D usampler;
uniform mediump uvec4 v;
uniform mediump int i;
uniform bool b;
flat in mediump uvec2 t;
in mediump vec2 tc;
in mediump float f;
out mediump uvec4 c;
const int C_3 = 3;
const vec2 C_vec2p1d0p = vec2(1.0);
const int C_4 = 4;
const int C_0 = 0;
const int C_462 = 462;
const ivec4 C_e5c0qg = ivec4(341413380);

void main()
{
	mediump int L_1 = ivec2(t).y + C_3;
	mediump vec2 L_2 = tc + C_vec2p1d0p;
	mediump ivec4 L_3 = ivec4(texture(usampler, L_2));
	ivec4 L_4 = ivec4((int(uint((float(L_1))))), (int((L_1 != C_0))), L_1, C_462);
	mediump ivec4 L_5 = ((ivec2(t).x > C_4) ? (L_3 + L_4) : L_3) + C_e5c0qg;
	c = uvec4(L_5);
	
}

#version 300 es
// LunarGOO output
precision mediump float; // this will be almost entirely overridden by individual declarations
uniform mediump usampler2D usampler;
uniform mediump uvec4 v;
uniform mediump int i;
uniform bool b;
flat in mediump uvec2 t;
in mediump vec2 tc;
in mediump float f;
out mediump uvec4 c;
const int C_3 = 3;
const vec2 C_vec2p1d0p = vec2(1.0);
const int C_4 = 4;
const int C_0 = 0;
const int C_462 = 462;
const ivec4 C_e5c0qg = ivec4(341413380);

void main()
{
	mediump int L_uc1 = ivec2(t).y + C_3;
	mediump vec2 L_uc2 = tc + C_vec2p1d0p;
	mediump ivec4 L_uc3 = ivec4(texture(usampler, L_uc2));
	ivec4 L_4 = ivec4((int(uint((float(L_uc1))))), (int((L_uc1 != C_0))), L_uc1, C_462);
	mediump ivec4 L_uc4 = ((ivec2(t).x > C_4) ? (L_4 + L_uc3) : L_uc3) + C_e5c0qg;
	c = uvec4(L_uc4);
	
}

