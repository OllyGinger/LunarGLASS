
Top IR:
; ModuleID = 'Top'

@Position_shadow = internal global <4 x float> zeroinitializer
@m4 = external addrspace(2) constant [4 x <4 x float>]
@v3_shadow = internal global <3 x float> zeroinitializer
@m3 = external addrspace(2) constant [3 x <3 x float>]
@VertexID_shadow = internal global i32 0

define fastcc void @main() {
entry:
  %constructed = alloca <4 x float>
  %param5 = alloca <3 x float>
  %param4 = alloca [3 x <3 x float>]
  %param1 = alloca <3 x float>
  %param = alloca [4 x <4 x float>]
  %param2 = load [4 x <4 x float>] addrspace(2)* @m4, !gla.uniform !3
  store [4 x <4 x float>] %param2, [4 x <4 x float>]* %param
  %v3 = call <3 x float> @llvm.gla.fReadData.v3f32(i32 1025, i32 -1), !gla.input !6
  store <3 x float> %v3, <3 x float>* @v3_shadow
  %param13 = load <3 x float>* @v3_shadow
  store <3 x float> %param13, <3 x float>* %param1
  %0 = call <3 x float> @"mxv(mf44;vf3;"([4 x <4 x float>]* %param, <3 x float>* %param1)
  %param46 = load [3 x <3 x float>] addrspace(2)* @m3, !gla.uniform !5
  store [3 x <3 x float>] %param46, [3 x <3 x float>]* %param4
  %v37 = call <3 x float> @llvm.gla.fReadData.v3f32(i32 1025, i32 -1), !gla.input !6
  store <3 x float> %v37, <3 x float>* @v3_shadow
  %param58 = load <3 x float>* @v3_shadow
  store <3 x float> %param58, <3 x float>* %param5
  %1 = call <3 x float> @"xf(mf33;vf3;"([3 x <3 x float>]* %param4, <3 x float>* %param5)
  %2 = fadd <3 x float> %0, %1
  %3 = load <4 x float>* %constructed
  %4 = extractelement <3 x float> %2, i32 0
  %5 = insertelement <4 x float> %3, float %4, i32 0
  %6 = extractelement <3 x float> %2, i32 1
  %7 = insertelement <4 x float> %5, float %6, i32 1
  %8 = extractelement <3 x float> %2, i32 2
  %9 = insertelement <4 x float> %7, float %8, i32 2
  %Position_shadow = insertelement <4 x float> %9, float 1.000000e+00, i32 3
  store <4 x float> %Position_shadow, <4 x float>* @Position_shadow
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %entry
  %10 = load <4 x float>* @Position_shadow
  call void @llvm.gla.fWriteData.v4f32(i32 1024, i32 -1, <4 x float> %10), !gla.output !1
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: alwaysinline
define internal fastcc <3 x float> @"xf(mf33;vf3;"([3 x <3 x float>]*, <3 x float>*) #0 {
entry:
  %2 = load <3 x float>* %1
  %3 = load [3 x <3 x float>]* %0
  %4 = alloca <3 x float>
  %5 = load <3 x float>* %4
  %column = extractvalue [3 x <3 x float>] %3, 0
  %dotres = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %column)
  %6 = insertelement <3 x float> %5, float %dotres, i32 0
  %column1 = extractvalue [3 x <3 x float>] %3, 1
  %dotres2 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %column1)
  %7 = insertelement <3 x float> %6, float %dotres2, i32 1
  %column3 = extractvalue [3 x <3 x float>] %3, 2
  %dotres4 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %column3)
  %8 = insertelement <3 x float> %7, float %dotres4, i32 2
  ret <3 x float> %8

post-return:                                      ; No predecessors!
  unreachable
}

; Function Attrs: alwaysinline
define internal fastcc [3 x <3 x float>] @"Mat3(mf44;"([4 x <4 x float>]*) #0 {
entry:
  %constructed = alloca [3 x <3 x float>]
  %1 = getelementptr [4 x <4 x float>]* %0, i32 0, i32 0
  %2 = load <4 x float>* %1
  %3 = extractelement <4 x float> %2, i32 0
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %2, i32 1
  %6 = insertelement <3 x float> %4, float %5, i32 1
  %7 = extractelement <4 x float> %2, i32 2
  %8 = insertelement <3 x float> %6, float %7, i32 2
  %9 = getelementptr [4 x <4 x float>]* %0, i32 0, i32 1
  %10 = load <4 x float>* %9
  %11 = extractelement <4 x float> %10, i32 0
  %12 = insertelement <3 x float> undef, float %11, i32 0
  %13 = extractelement <4 x float> %10, i32 1
  %14 = insertelement <3 x float> %12, float %13, i32 1
  %15 = extractelement <4 x float> %10, i32 2
  %16 = insertelement <3 x float> %14, float %15, i32 2
  %17 = getelementptr [4 x <4 x float>]* %0, i32 0, i32 2
  %18 = load <4 x float>* %17
  %19 = extractelement <4 x float> %18, i32 0
  %20 = insertelement <3 x float> undef, float %19, i32 0
  %21 = extractelement <4 x float> %18, i32 1
  %22 = insertelement <3 x float> %20, float %21, i32 1
  %23 = extractelement <4 x float> %18, i32 2
  %24 = insertelement <3 x float> %22, float %23, i32 2
  %25 = load [3 x <3 x float>]* %constructed
  %element = extractelement <3 x float> %8, i32 0
  %element1 = extractelement <3 x float> %8, i32 1
  %element2 = extractelement <3 x float> %8, i32 2
  %element3 = extractelement <3 x float> %16, i32 0
  %element4 = extractelement <3 x float> %16, i32 1
  %element5 = extractelement <3 x float> %16, i32 2
  %element6 = extractelement <3 x float> %24, i32 0
  %element7 = extractelement <3 x float> %24, i32 1
  %element8 = extractelement <3 x float> %24, i32 2
  %column = extractvalue [3 x <3 x float>] %25, 0
  %column9 = insertelement <3 x float> %column, float %element, i32 0
  %column10 = insertelement <3 x float> %column9, float %element1, i32 1
  %column11 = insertelement <3 x float> %column10, float %element2, i32 2
  %matrix = insertvalue [3 x <3 x float>] %25, <3 x float> %column11, 0
  %column12 = extractvalue [3 x <3 x float>] %25, 1
  %column13 = insertelement <3 x float> %column12, float %element3, i32 0
  %column14 = insertelement <3 x float> %column13, float %element4, i32 1
  %column15 = insertelement <3 x float> %column14, float %element5, i32 2
  %matrix16 = insertvalue [3 x <3 x float>] %matrix, <3 x float> %column15, 1
  %column17 = extractvalue [3 x <3 x float>] %25, 2
  %column18 = insertelement <3 x float> %column17, float %element6, i32 0
  %column19 = insertelement <3 x float> %column18, float %element7, i32 1
  %column20 = insertelement <3 x float> %column19, float %element8, i32 2
  %matrix21 = insertvalue [3 x <3 x float>] %matrix16, <3 x float> %column20, 2
  ret [3 x <3 x float>] %matrix21

post-return:                                      ; No predecessors!
  unreachable
}

; Function Attrs: alwaysinline
define internal fastcc <3 x float> @"mxv(mf44;vf3;"([4 x <4 x float>]*, <3 x float>*) #0 {
entry:
  %param = alloca [4 x <4 x float>]
  %2 = load <3 x float>* %1
  %param1 = load [4 x <4 x float>]* %0
  store [4 x <4 x float>] %param1, [4 x <4 x float>]* %param
  %3 = call [3 x <3 x float>] @"Mat3(mf44;"([4 x <4 x float>]* %param)
  %4 = alloca <3 x float>
  %5 = load <3 x float>* %4
  %column = extractvalue [3 x <3 x float>] %3, 0
  %dotres = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %column)
  %6 = insertelement <3 x float> %5, float %dotres, i32 0
  %column2 = extractvalue [3 x <3 x float>] %3, 1
  %dotres3 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %column2)
  %7 = insertelement <3 x float> %6, float %dotres3, i32 1
  %column4 = extractvalue [3 x <3 x float>] %3, 2
  %dotres5 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %column4)
  %8 = insertelement <3 x float> %7, float %dotres5, i32 2
  ret <3 x float> %8

post-return:                                      ; No predecessors!
  unreachable
}

; Function Attrs: nounwind readnone
declare float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float>, <3 x float>) #1

; Function Attrs: nounwind readonly
declare <3 x float> @llvm.gla.fReadData.v3f32(i32, i32) #2

; Function Attrs: nounwind
declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) #3

attributes #0 = { alwaysinline }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind readonly }
attributes #3 = { nounwind }

!gla.entrypoint = !{!0}
!gla.outputs = !{!1}
!gla.uniforms = !{!3, !5}
!gla.inputs = !{!6, !8}
!gla.noStaticUse = !{!8}

!0 = metadata !{metadata !"main", i32 15}
!1 = metadata !{metadata !"gl_Position", i32 8, <4 x float>* @Position_shadow_typeProxy, metadata !2}
!2 = metadata !{i32 0, i32 0, i32 1024, null, i32 0}
!3 = metadata !{metadata !"m4", i32 12, [4 x <4 x float>]* @m4_typeProxy, metadata !4}
!4 = metadata !{i32 3, i32 0, i32 1024, null}
!5 = metadata !{metadata !"m3", i32 12, [3 x <3 x float>]* @m3_typeProxy, metadata !4}
!6 = metadata !{metadata !"v3", i32 1, <3 x float>* @v3_shadow_typeProxy, metadata !7}
!7 = metadata !{i32 0, i32 0, i32 1025, null, i32 0}
!8 = metadata !{metadata !"gl_VertexID", i32 2, i32* @VertexID_shadow_typeProxy, metadata !9}
!9 = metadata !{i32 0, i32 0, i32 1026, null, i32 0}


Bottom IR:
; ModuleID = 'Top'

@m4 = external addrspace(2) constant [4 x <4 x float>]
@m3 = external addrspace(2) constant [3 x <3 x float>]

define fastcc void @main() {
entry:
  %param2 = load [4 x <4 x float>] addrspace(2)* @m4, align 16, !gla.uniform !3
  %v3 = call <3 x float> @llvm.gla.fReadData.v3f32(i32 1025, i32 -1), !gla.input !6
  %param212 = extractvalue [4 x <4 x float>] %param2, 0
  %0 = call <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float> %param212, <3 x i32> <i32 0, i32 1, i32 2>)
  %param213 = extractvalue [4 x <4 x float>] %param2, 1
  %1 = call <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float> %param213, <3 x i32> <i32 0, i32 1, i32 2>)
  %param214 = extractvalue [4 x <4 x float>] %param2, 2
  %2 = call <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float> %param214, <3 x i32> <i32 0, i32 1, i32 2>)
  %dotres.i = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3, <3 x float> %0)
  %dotres3.i = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3, <3 x float> %1)
  %dotres5.i = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3, <3 x float> %2)
  %3 = call <3 x float> @llvm.gla.fMultiInsert.v3f32.v3f32.f32.f32.f32.f32(<3 x float> undef, i32 7, float %dotres.i, i32 0, float %dotres3.i, i32 0, float %dotres5.i, i32 0, float undef, i32 undef)
  %param46 = load [3 x <3 x float>] addrspace(2)* @m3, align 16, !gla.uniform !5
  %column.i10 = extractvalue [3 x <3 x float>] %param46, 0
  %dotres.i11 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3, <3 x float> %column.i10)
  %column1.i = extractvalue [3 x <3 x float>] %param46, 1
  %dotres2.i = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3, <3 x float> %column1.i)
  %column3.i = extractvalue [3 x <3 x float>] %param46, 2
  %dotres4.i = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3, <3 x float> %column3.i)
  %4 = call <3 x float> @llvm.gla.fMultiInsert.v3f32.v3f32.f32.f32.f32.f32(<3 x float> undef, i32 7, float %dotres.i11, i32 0, float %dotres2.i, i32 0, float %dotres4.i, i32 0, float undef, i32 undef)
  %5 = fadd <3 x float> %3, %4
  %6 = call <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.v3f32.v3f32.v3f32.f32(<4 x float> undef, i32 15, <3 x float> %5, i32 0, <3 x float> %5, i32 1, <3 x float> %5, i32 2, float 1.000000e+00, i32 0)
  call void @llvm.gla.fWriteData.v4f32(i32 1024, i32 -1, <4 x float> %6), !gla.output !1
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %entry
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: nounwind readnone
declare float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float>, <3 x float>) #0

; Function Attrs: nounwind readonly
declare <3 x float> @llvm.gla.fReadData.v3f32(i32, i32) #1

; Function Attrs: nounwind
declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) #2

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.v3f32.v3f32.v3f32.f32(<4 x float>, i32, <3 x float>, i32, <3 x float>, i32, <3 x float>, i32, float, i32) #0

; Function Attrs: nounwind readnone
declare <3 x float> @llvm.gla.fMultiInsert.v3f32.v3f32.f32.f32.f32.f32(<3 x float>, i32, float, i32, float, i32, float, i32, float, i32) #0

; Function Attrs: nounwind readnone
declare <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float>, <3 x i32>) #0

attributes #0 = { nounwind readnone }
attributes #1 = { nounwind readonly }
attributes #2 = { nounwind }

!gla.entrypoint = !{!0}
!gla.outputs = !{!1}
!gla.uniforms = !{!3, !5}
!gla.inputs = !{!6, !8}
!gla.noStaticUse = !{!8}

!0 = metadata !{metadata !"main", i32 15}
!1 = metadata !{metadata !"gl_Position", i32 8, <4 x float>* @Position_shadow_typeProxy, metadata !2}
!2 = metadata !{i32 0, i32 0, i32 1024, null, i32 0}
!3 = metadata !{metadata !"m4", i32 12, [4 x <4 x float>]* @m4_typeProxy, metadata !4}
!4 = metadata !{i32 3, i32 0, i32 1024, null}
!5 = metadata !{metadata !"m3", i32 12, [3 x <3 x float>]* @m3_typeProxy, metadata !4}
!6 = metadata !{metadata !"v3", i32 1, <3 x float>* @v3_shadow_typeProxy, metadata !7}
!7 = metadata !{i32 0, i32 0, i32 1025, null, i32 0}
!8 = metadata !{metadata !"gl_VertexID", i32 2, i32* @VertexID_shadow_typeProxy, metadata !9}
!9 = metadata !{i32 0, i32 0, i32 1026, null, i32 0}
#### BEGIN COMPILER 0 INFO LOG ####
Warning, version 130 is not yet complete; most features are present, but a few are missing.
#### END COMPILER 0 INFO LOG ####
#version 130
// LunarGOO output (r722)
uniform mat4 m4;
uniform mat3 m3;
in vec3 v3;
const float const40 = 1.0;

void main()
{
    vec4 param212 = m4[0];
    vec3 temp22 = vec3(param212);
    vec4 param213 = m4[1];
    vec3 temp24 = vec3(param213);
    vec4 param214 = m4[2];
    vec3 temp26 = vec3(param214);
    float dotresdi = dot(v3, temp22);
    float dotres3di = dot(v3, temp24);
    float dotres5di = dot(v3, temp26);
    vec3 temp30;
    temp30.xyz = vec3(dotresdi, dotres3di, dotres5di);
    vec3 columndi10 = m3[0];
    float dotresdi11 = dot(v3, columndi10);
    vec3 column1di = m3[1];
    float dotres2di = dot(v3, column1di);
    vec3 column3di = m3[2];
    float dotres4di = dot(v3, column3di);
    vec3 temp37;
    temp37.xyz = vec3(dotresdi11, dotres2di, dotres4di);
    vec3 temp38 = temp30 + temp37;
    vec4 temp39 = vec4(temp38.x, temp38.y, temp38.z, const40);
    gl_Position = temp39;
    
}

#### BEGIN COMPILER 0 INFO LOG ####
Warning, version 130 is not yet complete; most features are present, but a few are missing.
#### END COMPILER 0 INFO LOG ####
#version 130
// LunarGOO output (r722)
uniform mat4 m4;
uniform mat3 m3;
in vec3 v3;
const float const34 = 1.0;

void main()
{
    vec3 temp21 = vec3(m4[0]);
    vec3 temp22 = vec3(m4[1]);
    vec3 temp23 = vec3(m4[2]);
    float dotresdi9 = dot(v3, temp21);
    float dotres3di11 = dot(v3, temp22);
    float dotres5di13 = dot(v3, temp23);
    vec3 temp27;
    temp27.xyz = vec3(dotresdi9, dotres3di11, dotres5di13);
    float dotresdi1118 = dot(v3, m3[0]);
    float dotres2di21 = dot(v3, m3[1]);
    float dotres4di24 = dot(v3, m3[2]);
    vec3 temp31;
    temp31.xyz = vec3(dotresdi1118, dotres2di21, dotres4di24);
    vec3 temp3827 = temp27 + temp31;
    vec4 temp33 = vec4(temp3827.x, temp3827.y, temp3827.z, const34);
    gl_Position = temp33;
    
}

