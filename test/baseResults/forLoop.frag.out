
Top IR:
; ModuleID = 'Glslang'

@BaseColor = global <4 x float> zeroinitializer
@Count = external addrspace(2) constant i32
@bigColor = external addrspace(2) constant <4 x float>
@gl_FragColor = global <4 x float> zeroinitializer
@v4 = external addrspace(2) constant <4 x i32>
@f = global float 0.000000e+00

define fastcc void @main() {
entry:
  %i34 = alloca i32
  %i24 = alloca i32
  %r = alloca <4 x float>
  %constructed = alloca <4 x float>
  %tv4 = alloca <4 x float>
  %i13 = alloca i32
  %i4 = alloca i32
  %sum = alloca float
  %i = alloca i32
  %color = alloca <4 x float>
  %color1 = load <4 x float>* @BaseColor
  store <4 x float> %color1, <4 x float>* %color
  store i32 0, i32* %i
  br label %loop-header

loop-header:                                      ; preds = %post-loop-continue, %ifmerge, %entry
  %0 = load i32* %i
  %1 = load i32 addrspace(2)* @Count, !gla.uniform !5
  %2 = icmp slt i32 %0, %1
  %3 = xor i1 %2, true
  br i1 %3, label %then, label %ifmerge

then:                                             ; preds = %loop-header
  br label %loop-merge

post-loop-break:                                  ; No predecessors!
  br label %ifmerge

ifmerge:                                          ; preds = %loop-header, %post-loop-break
  %4 = load <4 x float> addrspace(2)* @bigColor, !gla.uniform !7
  %5 = load <4 x float>* %color
  %color2 = fadd <4 x float> %5, %4
  store <4 x float> %color2, <4 x float>* %color
  %6 = load i32* %i
  %i3 = add i32 %6, 1
  store i32 %i3, i32* %i
  br label %loop-header

post-loop-continue:                               ; No predecessors!
  br label %loop-header

loop-merge:                                       ; preds = %then
  %gl_FragColor = load <4 x float>* %color
  store <4 x float> %gl_FragColor, <4 x float>* @gl_FragColor
  store float 0.000000e+00, float* %sum
  store i32 0, i32* %i4
  br label %loop-header5

loop-header5:                                     ; preds = %post-loop-continue11, %ifmerge8, %loop-merge
  %7 = load i32* %i4
  %8 = icmp slt i32 %7, 4
  %9 = xor i1 %8, true
  br i1 %9, label %then6, label %ifmerge8

then6:                                            ; preds = %loop-header5
  br label %loop-merge12

post-loop-break7:                                 ; No predecessors!
  br label %ifmerge8

ifmerge8:                                         ; preds = %loop-header5, %post-loop-break7
  %10 = load i32* %i4
  %11 = load <4 x i32> addrspace(2)* @v4, !gla.uniform !8
  %12 = extractelement <4 x i32> %11, i32 %10
  %13 = uitofp i32 %12 to float
  %14 = load float* %sum
  %sum9 = fadd float %14, %13
  store float %sum9, float* %sum
  %15 = load i32* %i4
  %i410 = add i32 %15, 1
  store i32 %i410, i32* %i4
  br label %loop-header5

post-loop-continue11:                             ; No predecessors!
  br label %loop-header5

loop-merge12:                                     ; preds = %then6
  store i32 0, i32* %i13
  br label %loop-header14

loop-header14:                                    ; preds = %post-loop-continue20, %ifmerge17, %loop-merge12
  %16 = load i32* %i13
  %17 = icmp slt i32 %16, 4
  %18 = xor i1 %17, true
  br i1 %18, label %then15, label %ifmerge17

then15:                                           ; preds = %loop-header14
  br label %loop-merge21

post-loop-break16:                                ; No predecessors!
  br label %ifmerge17

ifmerge17:                                        ; preds = %loop-header14, %post-loop-break16
  %19 = load i32* %i13
  %20 = load i32* %i13
  %21 = load <4 x i32> addrspace(2)* @v4, !gla.uniform !8
  %22 = extractelement <4 x i32> %21, i32 %20
  %23 = mul i32 %22, 4
  %24 = uitofp i32 %23 to float
  %25 = load <4 x float>* %tv4
  %tv418 = insertelement <4 x float> %25, float %24, i32 %19
  store <4 x float> %tv418, <4 x float>* %tv4
  %26 = load i32* %i13
  %i1319 = add i32 %26, 1
  store i32 %i1319, i32* %i13
  br label %loop-header14

post-loop-continue20:                             ; No predecessors!
  br label %loop-header14

loop-merge21:                                     ; preds = %then15
  %27 = load float* %sum
  %28 = load <4 x float>* %constructed
  %29 = insertelement <4 x float> undef, float %27, i32 0
  %30 = insertelement <4 x float> %29, float %27, i32 1
  %31 = insertelement <4 x float> %30, float %27, i32 2
  %32 = insertelement <4 x float> %31, float %27, i32 3
  %33 = load <4 x float>* %tv4
  %34 = fadd <4 x float> %32, %33
  %35 = load <4 x float>* @gl_FragColor
  %gl_FragColor22 = fadd <4 x float> %35, %34
  store <4 x float> %gl_FragColor22, <4 x float>* @gl_FragColor
  %36 = load <4 x float>* @BaseColor
  %37 = extractelement <4 x float> %36, i32 0
  %38 = insertelement <3 x float> undef, float %37, i32 0
  %39 = extractelement <4 x float> %36, i32 1
  %40 = insertelement <3 x float> %38, float %39, i32 1
  %41 = extractelement <4 x float> %36, i32 2
  %42 = insertelement <3 x float> %40, float %41, i32 2
  %43 = load <4 x float>* %r
  %44 = extractelement <3 x float> %42, i32 0
  %45 = insertelement <4 x float> %43, float %44, i32 0
  %46 = extractelement <3 x float> %42, i32 1
  %47 = insertelement <4 x float> %45, float %46, i32 1
  %48 = extractelement <3 x float> %42, i32 2
  %r23 = insertelement <4 x float> %47, float %48, i32 2
  store <4 x float> %r23, <4 x float>* %r
  store i32 0, i32* %i24
  br label %loop-header25

loop-header25:                                    ; preds = %post-loop-continue31, %ifmerge28, %loop-merge21
  %49 = load i32* %i24
  %50 = load i32 addrspace(2)* @Count, !gla.uniform !5
  %51 = icmp slt i32 %49, %50
  %52 = xor i1 %51, true
  br i1 %52, label %then26, label %ifmerge28

then26:                                           ; preds = %loop-header25
  br label %loop-merge32

post-loop-break27:                                ; No predecessors!
  br label %ifmerge28

ifmerge28:                                        ; preds = %loop-header25, %post-loop-break27
  %53 = load float* @f
  %54 = load <4 x float>* %r
  %r29 = insertelement <4 x float> %54, float %53, i32 3
  store <4 x float> %r29, <4 x float>* %r
  %55 = load i32* %i24
  %i2430 = add i32 %55, 1
  store i32 %i2430, i32* %i24
  br label %loop-header25

post-loop-continue31:                             ; No predecessors!
  br label %loop-header25

loop-merge32:                                     ; preds = %then26
  %56 = load <4 x float>* %r
  %57 = extractelement <4 x float> %56, i32 0
  %58 = insertelement <3 x float> undef, float %57, i32 0
  %59 = extractelement <4 x float> %56, i32 1
  %60 = insertelement <3 x float> %58, float %59, i32 1
  %61 = extractelement <4 x float> %56, i32 2
  %62 = insertelement <3 x float> %60, float %61, i32 2
  %63 = load <4 x float>* @gl_FragColor
  %64 = extractelement <4 x float> %63, i32 0
  %65 = insertelement <3 x float> undef, float %64, i32 0
  %66 = extractelement <4 x float> %63, i32 1
  %67 = insertelement <3 x float> %65, float %66, i32 1
  %68 = extractelement <4 x float> %63, i32 2
  %69 = insertelement <3 x float> %67, float %68, i32 2
  %70 = fadd <3 x float> %69, %62
  %71 = load <4 x float>* @gl_FragColor
  %72 = extractelement <3 x float> %70, i32 0
  %73 = insertelement <4 x float> %71, float %72, i32 0
  %74 = extractelement <3 x float> %70, i32 1
  %75 = insertelement <4 x float> %73, float %74, i32 1
  %76 = extractelement <3 x float> %70, i32 2
  %gl_FragColor33 = insertelement <4 x float> %75, float %76, i32 2
  store <4 x float> %gl_FragColor33, <4 x float>* @gl_FragColor
  store i32 0, i32* %i34
  br label %loop-header35

loop-header35:                                    ; preds = %post-loop-continue41, %ifmerge38, %loop-merge32
  %77 = load i32* %i34
  %78 = icmp slt i32 %77, 16
  %79 = xor i1 %78, true
  br i1 %79, label %then36, label %ifmerge38

then36:                                           ; preds = %loop-header35
  br label %loop-merge42

post-loop-break37:                                ; No predecessors!
  br label %ifmerge38

ifmerge38:                                        ; preds = %loop-header35, %post-loop-break37
  %80 = load float* @f
  %81 = load <4 x float>* @gl_FragColor
  %82 = insertelement <4 x float> undef, float %80, i32 0
  %83 = insertelement <4 x float> %82, float %80, i32 1
  %84 = insertelement <4 x float> %83, float %80, i32 2
  %85 = insertelement <4 x float> %84, float %80, i32 3
  %gl_FragColor39 = fmul <4 x float> %81, %85
  store <4 x float> %gl_FragColor39, <4 x float>* @gl_FragColor
  %86 = load i32* %i34
  %i3440 = add i32 %86, 4
  store i32 %i3440, i32* %i34
  br label %loop-header35

post-loop-continue41:                             ; No predecessors!
  br label %loop-header35

loop-merge42:                                     ; preds = %then36
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %loop-merge42
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

!gla.entrypoint = !{!0}
!gla.inputs = !{!1, !3}
!gla.uniforms = !{!5, !7, !8}
!gla.outputs = !{!10}

!0 = metadata !{metadata !"main", i32 15}
!1 = metadata !{metadata !"BaseColor", i32 1, <4 x float>* @BaseColor_typeProxy, metadata !2}
!2 = metadata !{i32 0, i32 0, i32 1024, null, i32 1}
!3 = metadata !{metadata !"f", i32 1, float* @f_typeProxy, metadata !4}
!4 = metadata !{i32 0, i32 0, i32 1026, null, i32 1}
!5 = metadata !{metadata !"Count", i32 12, i32* @Count_typeProxy, metadata !6}
!6 = metadata !{i32 0, i32 0, i32 1024, null}
!7 = metadata !{metadata !"bigColor", i32 12, <4 x float>* @bigColor_typeProxy, metadata !6}
!8 = metadata !{metadata !"v4", i32 12, <4 x i32>* @v4_typeProxy, metadata !9}
!9 = metadata !{i32 1, i32 0, i32 1024, null}
!10 = metadata !{metadata !"gl_FragColor", i32 7, <4 x float>* @gl_FragColor_typeProxy, metadata !11}
!11 = metadata !{i32 0, i32 0, i32 1025, null, i32 0}


Bottom IR:
; ModuleID = 'Glslang'

@BaseColor = global <4 x float> zeroinitializer
@Count = external addrspace(2) constant i32
@bigColor = external addrspace(2) constant <4 x float>
@gl_FragColor = global <4 x float> zeroinitializer
@v4 = external addrspace(2) constant <4 x i32>
@f = global float 0.000000e+00
@gla_globalAgg = internal global <4 x float> undef

define fastcc void @main() {
entry:
  %color1 = load <4 x float>* @BaseColor, align 16
  %.pre = load i32 addrspace(2)* @Count, align 4, !gla.uniform !5
  %0 = load <4 x float> addrspace(2)* @bigColor, align 16, !gla.uniform !7
  br label %loop-header

loop-header:                                      ; preds = %ifmerge, %entry
  %1 = phi <4 x float> [ %color1, %entry ], [ %color2, %ifmerge ]
  %i.0 = phi i32 [ 0, %entry ], [ %i3, %ifmerge ]
  %2 = icmp slt i32 %i.0, %.pre
  br i1 %2, label %ifmerge, label %then

then:                                             ; preds = %loop-header
  store <4 x float> %1, <4 x float>* @gl_FragColor, align 16
  %3 = load <4 x i32> addrspace(2)* @v4, align 16, !gla.uniform !8
  %4 = extractelement <4 x i32> %3, i32 0
  %5 = uitofp i32 %4 to float
  %6 = extractelement <4 x i32> %3, i32 1
  %7 = uitofp i32 %6 to float
  %sum9.1 = fadd float %5, %7
  %8 = extractelement <4 x i32> %3, i32 2
  %9 = uitofp i32 %8 to float
  %sum9.2 = fadd float %sum9.1, %9
  %10 = extractelement <4 x i32> %3, i32 3
  %11 = uitofp i32 %10 to float
  %sum9.3 = fadd float %sum9.2, %11
  %12 = call <4 x float> @llvm.gla.fSwizzle.v4f32.f32.v4i32(float %sum9.3, <4 x i32> zeroinitializer)
  %13 = shl i32 %4, 2
  %14 = uitofp i32 %13 to float
  %aggregate = load <4 x float>* @gla_globalAgg
  %tv418 = insertelement <4 x float> %aggregate, float %14, i32 0
  %15 = shl i32 %6, 2
  %16 = uitofp i32 %15 to float
  %tv418.1 = insertelement <4 x float> %tv418, float %16, i32 1
  %17 = shl i32 %8, 2
  %18 = uitofp i32 %17 to float
  %tv418.2 = insertelement <4 x float> %tv418.1, float %18, i32 2
  %19 = shl i32 %10, 2
  %20 = uitofp i32 %19 to float
  %tv418.3 = insertelement <4 x float> %tv418.2, float %20, i32 3
  %21 = fadd <4 x float> %12, %tv418.3
  %gl_FragColor22 = fadd <4 x float> %21, %1
  %22 = call <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float> %gl_FragColor22, <3 x i32> <i32 0, i32 1, i32 2>)
  store <4 x float> %gl_FragColor22, <4 x float>* @gl_FragColor, align 16
  %23 = load float* @f, align 4
  %24 = call <4 x float> @llvm.gla.fSwizzle.v4f32.f32.v4i32(float %23, <4 x i32> zeroinitializer)
  br label %loop-header25

ifmerge:                                          ; preds = %loop-header
  %color2 = fadd <4 x float> %1, %0
  %i3 = add i32 %i.0, 1
  br label %loop-header

loop-header25:                                    ; preds = %ifmerge28, %then
  %r.0 = phi <4 x float> [ %color1, %then ], [ %29, %ifmerge28 ]
  %i24.0 = phi i32 [ 0, %then ], [ %i2430, %ifmerge28 ]
  %25 = call <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float> %r.0, <3 x i32> <i32 0, i32 1, i32 2>)
  %26 = icmp slt i32 %i24.0, %.pre
  br i1 %26, label %ifmerge28, label %then26

then26:                                           ; preds = %loop-header25
  %27 = fadd <3 x float> %25, %22
  %28 = call <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.v3f32.v3f32.v3f32.f32(<4 x float> %gl_FragColor22, i32 7, <3 x float> %27, i32 0, <3 x float> %27, i32 1, <3 x float> %27, i32 2, float undef, i32 undef)
  %gl_FragColor39 = fmul <4 x float> %28, %24
  %gl_FragColor39.1 = fmul <4 x float> %gl_FragColor39, %24
  %gl_FragColor39.2 = fmul <4 x float> %gl_FragColor39.1, %24
  %gl_FragColor39.3 = fmul <4 x float> %gl_FragColor39.2, %24
  store <4 x float> %gl_FragColor39.3, <4 x float>* @gl_FragColor, align 16
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %then26
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void

ifmerge28:                                        ; preds = %loop-header25
  %29 = call <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.f32.f32.f32.f32(<4 x float> %r.0, i32 8, float undef, i32 undef, float undef, i32 undef, float undef, i32 undef, float %23, i32 0)
  %i2430 = add i32 %i24.0, 1
  br label %loop-header25
}

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.f32.f32.f32.f32(<4 x float>, i32, float, i32, float, i32, float, i32, float, i32) #0

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.v3f32.v3f32.v3f32.f32(<4 x float>, i32, <3 x float>, i32, <3 x float>, i32, <3 x float>, i32, float, i32) #0

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fSwizzle.v4f32.f32.v4i32(float, <4 x i32>) #0

; Function Attrs: nounwind readnone
declare <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float>, <3 x i32>) #0

attributes #0 = { nounwind readnone }

!gla.entrypoint = !{!0}
!gla.inputs = !{!1, !3}
!gla.uniforms = !{!5, !7, !8}
!gla.outputs = !{!10}

!0 = metadata !{metadata !"main", i32 15}
!1 = metadata !{metadata !"BaseColor", i32 1, <4 x float>* @BaseColor_typeProxy, metadata !2}
!2 = metadata !{i32 0, i32 0, i32 1024, null, i32 1}
!3 = metadata !{metadata !"f", i32 1, float* @f_typeProxy, metadata !4}
!4 = metadata !{i32 0, i32 0, i32 1026, null, i32 1}
!5 = metadata !{metadata !"Count", i32 12, i32* @Count_typeProxy, metadata !6}
!6 = metadata !{i32 0, i32 0, i32 1024, null}
!7 = metadata !{metadata !"bigColor", i32 12, <4 x float>* @bigColor_typeProxy, metadata !6}
!8 = metadata !{metadata !"v4", i32 12, <4 x i32>* @v4_typeProxy, metadata !9}
!9 = metadata !{i32 1, i32 0, i32 1024, null}
!10 = metadata !{metadata !"gl_FragColor", i32 7, <4 x float>* @gl_FragColor_typeProxy, metadata !11}
!11 = metadata !{i32 0, i32 0, i32 1025, null, i32 0}
#version 130
// LunarGOO output
uniform int Count;
uniform vec4 bigColor;
uniform uvec4 v4;
in vec4 BaseColor;
in float f;
vec4 gla_globalAgg;
const int C_0 = 0;
const int C_2 = 2;
vec3 Lg_3;
const int C_1 = 1;

void main()
{
	vec4 Lg_1;
	int i_uc1;
	vec4 r_uc2;
	int Lg_2;
	Lg_1 = BaseColor;
	i_uc1 = C_0;
	for (i_uc1 = 0; i_uc1 < Count; ++i_uc1) {
		vec4 color_c3 = Lg_1 + bigColor;
		Lg_1 = color_c3;
	}
	
	gl_FragColor = Lg_1;
	float H_i1jho5 = float(ivec4(v4).x);
	float H_ry83gd = float(ivec4(v4).y);
	float sum_c4 = H_i1jho5 + H_ry83gd;
	float H_49uxyc1 = float(ivec4(v4).z);
	float sum_c5 = H_49uxyc1 + sum_c4;
	float H_dx9e2e1 = float(ivec4(v4).w);
	float sum_c6 = H_dx9e2e1 + sum_c5;
	vec4 H_fppcf01 = vec4(sum_c6);
	int H_jv91f2 = ivec4(v4).x << C_2;
	float H_nmn79w = float(H_jv91f2);
	vec4 tv_c7 = gla_globalAgg;
	tv_c7.x = H_nmn79w;
	int H_ia5bsh1 = ivec4(v4).y << C_2;
	float H_ytz9bk = float(H_ia5bsh1);
	vec4 tv_c8 = tv_c7;
	tv_c8.y = H_ytz9bk;
	int H_5dx4dh = ivec4(v4).z << C_2;
	float H_ycbb6d = float(H_5dx4dh);
	vec4 tv_c9 = tv_c8;
	tv_c9.z = H_ycbb6d;
	int H_45zg0s1 = ivec4(v4).w << C_2;
	float H_pekchw = float(H_45zg0s1);
	vec4 tv_c10 = tv_c9;
	tv_c10.w = H_pekchw;
	vec4 H_6iqnxk1 = H_fppcf01 + tv_c10;
	vec4 Ll_FragColor_c11 = H_6iqnxk1 + Lg_1;
	gl_FragColor = Ll_FragColor_c11;
	vec4 H_wlwz58 = vec4(f);
	r_uc2 = BaseColor;
	Lg_2 = C_0;
	while (true) {
		bool H_mcxey01 = Lg_2 < Count;
		if (! H_mcxey01) {
			break;
		}
		
		vec4 H_opz8bh1 = r_uc2;
		H_opz8bh1.w = f;
		int H_5l4rig = Lg_2 + C_1;
		r_uc2 = H_opz8bh1;
		Lg_2 = H_5l4rig;
	}
	
	vec3 H_b3ap6m = Ll_FragColor_c11.xyz + r_uc2.xyz;
	vec4 H_9dsdr4 = Ll_FragColor_c11;
	H_9dsdr4.xyz = H_b3ap6m.xyz;
	vec4 Ll_FragColor_c12 = H_9dsdr4 * H_wlwz58;
	vec4 Ll_FragColor_c13 = H_wlwz58 * Ll_FragColor_c12;
	vec4 Ll_FragColor_c14 = H_wlwz58 * Ll_FragColor_c13;
	vec4 Ll_FragColor_c15 = H_wlwz58 * Ll_FragColor_c14;
	gl_FragColor = Ll_FragColor_c15;
	
}

#version 130
// LunarGOO output
uniform int Count;
uniform vec4 bigColor;
uniform uvec4 v4;
in vec4 BaseColor;
in float f;
const int C_0 = 0;
const int C_2 = 2;
vec3 Lg_1;
const int C_1 = 1;

void main()
{
	int i_uc_c1;
	vec4 Lg_uc2;
	int Lg_uc3;
	vec4 r_uc_c4;
	i_uc_c1 = C_0;
	Lg_uc2 = BaseColor;
	for (i_uc_c1 = 0; i_uc_c1 < Count; ++i_uc_c1) {
		vec4 color_c5 = Lg_uc2 + bigColor;
		Lg_uc2 = color_c5;
	}
	
	gl_FragColor = Lg_uc2;
	float H_i_c6 = float(ivec4(v4).x);
	float H_ry_c7 = float(ivec4(v4).y);
	float sum_c8 = H_i_c6 + H_ry_c7;
	float H_uc9 = float(ivec4(v4).z);
	float sum_c10 = H_uc9 + sum_c8;
	float H_dx_c11 = float(ivec4(v4).w);
	float sum_c12 = H_dx_c11 + sum_c10;
	vec4 H_swai5n = vec4(sum_c12);
	int H_jv_c13 = ivec4(v4).x << C_2;
	float H_nmn_c14 = float(H_jv_c13);
	int H_ia_c15 = ivec4(v4).y << C_2;
	float H_ytz_c16 = float(H_ia_c15);
	int H_uc17 = ivec4(v4).z << C_2;
	float H_ycbb_c18 = float(H_uc17);
	int H_uc19 = ivec4(v4).w << C_2;
	float H_pekchw_c20 = float(H_uc19);
	vec4 H_xvhea21 = vec4(H_nmn_c14, H_ytz_c16, H_ycbb_c18, H_pekchw_c20);
	vec4 H_uc21 = H_swai5n + H_xvhea21;
	vec4 Ll_FragColor_c22 = H_uc21 + Lg_uc2;
	gl_FragColor = Ll_FragColor_c22;
	vec4 H_wlwz58 = vec4(f);
	Lg_uc3 = C_0;
	r_uc_c4 = BaseColor;
	while (true) {
		bool H_x6z1i2 = Lg_uc3 < Count;
		if (! H_x6z1i2) {
			break;
		}
		
		vec4 H_or427q = r_uc_c4;
		H_or427q.w = f;
		int H_uc23 = Lg_uc3 + C_1;
		Lg_uc3 = H_uc23;
		r_uc_c4 = H_or427q;
	}
	
	vec3 H_b_c24 = Ll_FragColor_c22.xyz + r_uc_c4.xyz;
	vec4 H_jm7e92 = Ll_FragColor_c22;
	H_jm7e92.xyz = H_b_c24.xyz;
	vec4 Ll_FragColor_c25 = H_jm7e92 * H_wlwz58;
	vec4 Ll_FragColor_c26 = H_wlwz58 * Ll_FragColor_c25;
	vec4 Ll_FragColor_c27 = H_wlwz58 * Ll_FragColor_c26;
	vec4 Ll_FragColor_c28 = H_wlwz58 * Ll_FragColor_c27;
	gl_FragColor = Ll_FragColor_c28;
	
}

