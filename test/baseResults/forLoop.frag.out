
Top IR:
; ModuleID = 'Glslang'

@BaseColor_shadow = internal global <4 x float> zeroinitializer
@Count = external addrspace(2) constant i32
@bigColor = external addrspace(2) constant <4 x float>
@FragColor_shadow = internal global <4 x float> zeroinitializer
@v4 = external addrspace(2) constant <4 x i32>

define fastcc void @main() {
entry:
  %constructed = alloca <4 x float>
  %tv4 = alloca <4 x float>
  %i13 = alloca i32
  %i4 = alloca i32
  %sum = alloca float
  %i = alloca i32
  %color = alloca <4 x float>
  %BaseColor = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 1024, i32 -1, i32 1), !gla.input !1
  store <4 x float> %BaseColor, <4 x float>* @BaseColor_shadow
  %color1 = load <4 x float>* @BaseColor_shadow
  store <4 x float> %color1, <4 x float>* %color
  store i32 0, i32* %i
  br label %loop-header

loop-header:                                      ; preds = %post-loop-continue, %ifmerge, %entry
  %0 = load i32* %i
  %1 = load i32 addrspace(2)* @Count, !gla.uniform !3
  %2 = icmp slt i32 %0, %1
  %3 = xor i1 %2, true
  br i1 %3, label %then, label %ifmerge

then:                                             ; preds = %loop-header
  br label %loop-merge

post-loop-break:                                  ; No predecessors!
  br label %ifmerge

ifmerge:                                          ; preds = %loop-header, %post-loop-break
  %4 = load <4 x float> addrspace(2)* @bigColor, !gla.uniform !5
  %5 = load <4 x float>* %color
  %color2 = fadd <4 x float> %5, %4
  store <4 x float> %color2, <4 x float>* %color
  %6 = load i32* %i
  %i3 = add i32 %6, 1
  store i32 %i3, i32* %i
  br label %loop-header

post-loop-continue:                               ; No predecessors!
  br label %loop-header

loop-merge:                                       ; preds = %then
  %FragColor_shadow = load <4 x float>* %color
  store <4 x float> %FragColor_shadow, <4 x float>* @FragColor_shadow
  store float 0.000000e+00, float* %sum
  store i32 0, i32* %i4
  br label %loop-header5

loop-header5:                                     ; preds = %post-loop-continue11, %ifmerge8, %loop-merge
  %7 = load i32* %i4
  %8 = icmp slt i32 %7, 4
  %9 = xor i1 %8, true
  br i1 %9, label %then6, label %ifmerge8

then6:                                            ; preds = %loop-header5
  br label %loop-merge12

post-loop-break7:                                 ; No predecessors!
  br label %ifmerge8

ifmerge8:                                         ; preds = %loop-header5, %post-loop-break7
  %10 = load i32* %i4
  %11 = load <4 x i32> addrspace(2)* @v4, !gla.uniform !6
  %12 = extractelement <4 x i32> %11, i32 %10
  %13 = uitofp i32 %12 to float
  %14 = load float* %sum
  %sum9 = fadd float %14, %13
  store float %sum9, float* %sum
  %15 = load i32* %i4
  %i410 = add i32 %15, 1
  store i32 %i410, i32* %i4
  br label %loop-header5

post-loop-continue11:                             ; No predecessors!
  br label %loop-header5

loop-merge12:                                     ; preds = %then6
  store i32 0, i32* %i13
  br label %loop-header14

loop-header14:                                    ; preds = %post-loop-continue20, %ifmerge17, %loop-merge12
  %16 = load i32* %i13
  %17 = icmp slt i32 %16, 4
  %18 = xor i1 %17, true
  br i1 %18, label %then15, label %ifmerge17

then15:                                           ; preds = %loop-header14
  br label %loop-merge21

post-loop-break16:                                ; No predecessors!
  br label %ifmerge17

ifmerge17:                                        ; preds = %loop-header14, %post-loop-break16
  %19 = load i32* %i13
  %20 = load i32* %i13
  %21 = load <4 x i32> addrspace(2)* @v4, !gla.uniform !6
  %22 = extractelement <4 x i32> %21, i32 %20
  %23 = mul i32 %22, 4
  %24 = uitofp i32 %23 to float
  %25 = load <4 x float>* %tv4
  %tv418 = insertelement <4 x float> %25, float %24, i32 %19
  store <4 x float> %tv418, <4 x float>* %tv4
  %26 = load i32* %i13
  %i1319 = add i32 %26, 1
  store i32 %i1319, i32* %i13
  br label %loop-header14

post-loop-continue20:                             ; No predecessors!
  br label %loop-header14

loop-merge21:                                     ; preds = %then15
  %27 = load float* %sum
  %28 = load <4 x float>* %constructed
  %29 = insertelement <4 x float> undef, float %27, i32 0
  %30 = insertelement <4 x float> %29, float %27, i32 1
  %31 = insertelement <4 x float> %30, float %27, i32 2
  %32 = insertelement <4 x float> %31, float %27, i32 3
  %33 = load <4 x float>* %tv4
  %34 = fadd <4 x float> %32, %33
  %35 = load <4 x float>* @FragColor_shadow
  %FragColor_shadow22 = fadd <4 x float> %35, %34
  store <4 x float> %FragColor_shadow22, <4 x float>* @FragColor_shadow
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %loop-merge21
  %36 = load <4 x float>* @FragColor_shadow
  call void @llvm.gla.fWriteData.v4f32(i32 1025, i32 -1, <4 x float> %36), !gla.output !8
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32, i32, i32) #0

; Function Attrs: nounwind
declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) #1

attributes #0 = { nounwind readnone }
attributes #1 = { nounwind }

!gla.entrypoint = !{!0}
!gla.inputs = !{!1}
!gla.uniforms = !{!3, !5, !6}
!gla.outputs = !{!8}

!0 = metadata !{metadata !"main", i32 15}
!1 = metadata !{metadata !"BaseColor", i32 1, <4 x float>* @BaseColor_shadow_typeProxy, metadata !2}
!2 = metadata !{i32 0, i32 0, i32 1024, null, i32 1}
!3 = metadata !{metadata !"Count", i32 12, i32* @Count_typeProxy, metadata !4}
!4 = metadata !{i32 0, i32 0, i32 1024, null}
!5 = metadata !{metadata !"bigColor", i32 12, <4 x float>* @bigColor_typeProxy, metadata !4}
!6 = metadata !{metadata !"v4", i32 12, <4 x i32>* @v4_typeProxy, metadata !7}
!7 = metadata !{i32 1, i32 0, i32 1024, null}
!8 = metadata !{metadata !"gl_FragColor", i32 7, <4 x float>* @FragColor_shadow_typeProxy, metadata !9}
!9 = metadata !{i32 0, i32 0, i32 1025, null, i32 0}


Bottom IR:
; ModuleID = 'Glslang'

@Count = external addrspace(2) constant i32
@bigColor = external addrspace(2) constant <4 x float>
@v4 = external addrspace(2) constant <4 x i32>
@gla_globalAgg = internal global <4 x float> undef

define fastcc void @main() {
entry:
  %BaseColor = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 1024, i32 -1, i32 1), !gla.input !1
  %.pre = load i32 addrspace(2)* @Count, align 4, !gla.uniform !3
  %0 = load <4 x float> addrspace(2)* @bigColor, align 16, !gla.uniform !5
  br label %loop-header

loop-header:                                      ; preds = %ifmerge, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %i3, %ifmerge ]
  %color.0 = phi <4 x float> [ %BaseColor, %entry ], [ %color2, %ifmerge ]
  %1 = icmp slt i32 %i.0, %.pre
  br i1 %1, label %ifmerge, label %then

then:                                             ; preds = %loop-header
  %2 = load <4 x i32> addrspace(2)* @v4, align 16, !gla.uniform !6
  %3 = extractelement <4 x i32> %2, i32 0
  %4 = uitofp i32 %3 to float
  %5 = extractelement <4 x i32> %2, i32 1
  %6 = uitofp i32 %5 to float
  %sum9.1 = fadd float %4, %6
  %7 = extractelement <4 x i32> %2, i32 2
  %8 = uitofp i32 %7 to float
  %sum9.2 = fadd float %sum9.1, %8
  %9 = extractelement <4 x i32> %2, i32 3
  %10 = uitofp i32 %9 to float
  %sum9.3 = fadd float %sum9.2, %10
  %11 = call <4 x float> @llvm.gla.fSwizzle.v4f32.f32.v4i32(float %sum9.3, <4 x i32> zeroinitializer)
  %12 = shl i32 %3, 2
  %13 = uitofp i32 %12 to float
  %aggregate = load <4 x float>* @gla_globalAgg
  %tv418 = insertelement <4 x float> %aggregate, float %13, i32 0
  %14 = shl i32 %5, 2
  %15 = uitofp i32 %14 to float
  %tv418.1 = insertelement <4 x float> %tv418, float %15, i32 1
  %16 = shl i32 %7, 2
  %17 = uitofp i32 %16 to float
  %tv418.2 = insertelement <4 x float> %tv418.1, float %17, i32 2
  %18 = shl i32 %9, 2
  %19 = uitofp i32 %18 to float
  %tv418.3 = insertelement <4 x float> %tv418.2, float %19, i32 3
  %20 = fadd <4 x float> %11, %tv418.3
  %FragColor_shadow22 = fadd <4 x float> %color.0, %20
  call void @llvm.gla.fWriteData.v4f32(i32 1025, i32 -1, <4 x float> %FragColor_shadow22), !gla.output !8
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %then
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void

ifmerge:                                          ; preds = %loop-header
  %color2 = fadd <4 x float> %color.0, %0
  %i3 = add i32 %i.0, 1
  br label %loop-header
}

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32, i32, i32) #0

; Function Attrs: nounwind
declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) #1

; Function Attrs: nounwind readnone
declare <4 x float> @llvm.gla.fSwizzle.v4f32.f32.v4i32(float, <4 x i32>) #0

attributes #0 = { nounwind readnone }
attributes #1 = { nounwind }

!gla.entrypoint = !{!0}
!gla.inputs = !{!1}
!gla.uniforms = !{!3, !5, !6}
!gla.outputs = !{!8}

!0 = metadata !{metadata !"main", i32 15}
!1 = metadata !{metadata !"BaseColor", i32 1, <4 x float>* @BaseColor_shadow_typeProxy, metadata !2}
!2 = metadata !{i32 0, i32 0, i32 1024, null, i32 1}
!3 = metadata !{metadata !"Count", i32 12, i32* @Count_typeProxy, metadata !4}
!4 = metadata !{i32 0, i32 0, i32 1024, null}
!5 = metadata !{metadata !"bigColor", i32 12, <4 x float>* @bigColor_typeProxy, metadata !4}
!6 = metadata !{metadata !"v4", i32 12, <4 x i32>* @v4_typeProxy, metadata !7}
!7 = metadata !{i32 1, i32 0, i32 1024, null}
!8 = metadata !{metadata !"gl_FragColor", i32 7, <4 x float>* @FragColor_shadow_typeProxy, metadata !9}
!9 = metadata !{i32 0, i32 0, i32 1025, null, i32 0}
#version 130
// LunarGOO output
uniform int Count;
uniform vec4 bigColor;
uniform uvec4 v4;
in vec4 BaseColor;
vec4 gla_globalAgg;
const int const23i_0 = 0;
const int const27i_1 = 1;
const int const37i_2 = 2;

void main()
{
    int i_uc1;
    vec4 color_uc2;
    i_uc1 = const23i_0;
    color_uc2 = BaseColor;
    while (true) {
        bool temp24 = i_uc1 < Count;
        if (! temp24) {
            break;
        }
        
        vec4 color_c3 = bigColor + color_uc2;
        int temp26 = i_uc1 + const27i_1;
        i_uc1 = temp26;
        color_uc2 = color_c3;
    }
    
    float temp28 = float(ivec4(v4).x);
    float temp29 = float(ivec4(v4).y);
    float sum_c4 = temp28 + temp29;
    float temp31 = float(ivec4(v4).z);
    float sum_c5 = sum_c4 + temp31;
    float temp33 = float(ivec4(v4).w);
    float sum_c6 = sum_c5 + temp33;
    vec4 temp35 = vec4(sum_c6);
    int temp36 = ivec4(v4).x << const37i_2;
    float temp38 = float(temp36);
    vec4 tv_c7 = gla_globalAgg;
    tv_c7.x = temp38;
    int temp40 = ivec4(v4).y << const37i_2;
    float temp41 = float(temp40);
    vec4 tv_c8 = tv_c7;
    tv_c8.y = temp41;
    int temp43 = ivec4(v4).z << const37i_2;
    float temp44 = float(temp43);
    vec4 tv_c9 = tv_c8;
    tv_c9.z = temp44;
    int temp46 = ivec4(v4).w << const37i_2;
    float temp47 = float(temp46);
    vec4 tv_c10 = tv_c9;
    tv_c10.w = temp47;
    vec4 temp49 = temp35 + tv_c10;
    vec4 FragColor_shadow_c11 = color_uc2 + temp49;
    gl_FragColor = FragColor_shadow_c11;
    
}


#version 130
// LunarGOO output
uniform int Count;
uniform vec4 bigColor;
uniform uvec4 v4;
in vec4 BaseColor;
const int const23i_0 = 0;
const int const27i_1 = 1;
const int const37i_2 = 2;

void main()
{
    vec4 color_uc_c1;
    int i_uc_c2;
    color_uc_c1 = BaseColor;
    i_uc_c2 = const23i_0;
    while (true) {
        bool temp24 = i_uc_c2 < Count;
        if (! temp24) {
            break;
        }
        
        vec4 color_c3 = bigColor + color_uc_c1;
        int temp_c4 = i_uc_c2 + const27i_1;
        color_uc_c1 = color_c3;
        i_uc_c2 = temp_c4;
    }
    
    float temp_c5 = float(ivec4(v4).x);
    float temp_c6 = float(ivec4(v4).y);
    float sum_c7 = temp_c5 + temp_c6;
    float temp_c8 = float(ivec4(v4).z);
    float sum_c9 = sum_c7 + temp_c8;
    float temp_c10 = float(ivec4(v4).w);
    float sum_c11 = sum_c9 + temp_c10;
    vec4 temp35 = vec4(sum_c11);
    int temp_c12 = ivec4(v4).x << const37i_2;
    int temp_c13 = ivec4(v4).y << const37i_2;
    float temp_c14 = float(temp_c12);
    int temp_c15 = ivec4(v4).z << const37i_2;
    float temp_c16 = float(temp_c13);
    int temp_c17 = ivec4(v4).w << const37i_2;
    float temp_c18 = float(temp_c15);
    float temp_c19 = float(temp_c17);
    vec4 temp45 = vec4(temp_c14, temp_c16, temp_c18, temp_c19);
    vec4 temp_c20 = temp35 + temp45;
    vec4 FragColor_shadow_c21 = color_uc_c1 + temp_c20;
    gl_FragColor = FragColor_shadow_c21;
    
}


