
Top IR:
; ModuleID = 'Top'

@BaseColor_shadow = internal global <4 x float> zeroinitializer
@Count = external addrspace(2) constant i32
@bigColor = external addrspace(2) constant <4 x float>
@FragColor_shadow = internal global <4 x float> zeroinitializer

define fastcc void @main() {
entry:
  %i = alloca i32
  %color = alloca <4 x float>
  %BaseColor__ = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 0, i32 -1, i32 1)
  store <4 x float> %BaseColor__, <4 x float>* @BaseColor_shadow
  %color1 = load <4 x float>* @BaseColor_shadow
  store <4 x float> %color1, <4 x float>* %color
  store i32 0, i32* %i
  br label %loop-header

loop-header:                                      ; preds = %post-loop-continue, %ifmerge, %entry
  %0 = load i32* %i
  %1 = load i32 addrspace(2)* @Count
  %2 = icmp slt i32 %0, %1
  %3 = xor i1 %2, true
  br i1 %3, label %then, label %ifmerge

then:                                             ; preds = %loop-header
  br label %loop-merge

post-loop-break:                                  ; No predecessors!
  br label %ifmerge

ifmerge:                                          ; preds = %loop-header, %post-loop-break
  %4 = load <4 x float> addrspace(2)* @bigColor
  %5 = load <4 x float>* %color
  %color2 = fadd <4 x float> %5, %4
  store <4 x float> %color2, <4 x float>* %color
  %6 = load i32* %i
  %i3 = add i32 %6, 1
  store i32 %i3, i32* %i
  br label %loop-header

post-loop-continue:                               ; No predecessors!
  br label %loop-header

loop-merge:                                       ; preds = %then
  %FragColor_shadow = load <4 x float>* %color
  store <4 x float> %FragColor_shadow, <4 x float>* @FragColor_shadow
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %loop-merge
  %7 = load <4 x float>* @FragColor_shadow
  call void @llvm.gla.fWriteData.v4f32(i32 0, i32 -1, <4 x float> %7)
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

declare <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32, i32, i32) nounwind readnone

declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) nounwind


Bottom IR:
; ModuleID = 'Top'

@Count = external addrspace(2) constant i32
@bigColor = external addrspace(2) constant <4 x float>

define fastcc void @main() {
entry:
  %BaseColor__ = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 0, i32 -1, i32 1)
  %.pre = load i32 addrspace(2)* @Count, align 4
  %0 = load <4 x float> addrspace(2)* @bigColor, align 16
  %1 = icmp sgt i32 %.pre, 0
  br i1 %1, label %ifmerge.lr.ph, label %then

ifmerge.lr.ph:                                    ; preds = %entry
  br label %ifmerge

loop-header.then_crit_edge:                       ; preds = %ifmerge
  br label %then

then:                                             ; preds = %loop-header.then_crit_edge, %entry
  %color.0.lcssa = phi <4 x float> [ %color2, %loop-header.then_crit_edge ], [ %BaseColor__, %entry ]
  call void @llvm.gla.fWriteData.v4f32(i32 0, i32 -1, <4 x float> %color.0.lcssa)
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %then
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void

ifmerge:                                          ; preds = %ifmerge, %ifmerge.lr.ph
  %indvar = phi i32 [ %indvar.next, %ifmerge ], [ 0, %ifmerge.lr.ph ]
  %color.07 = phi <4 x float> [ %BaseColor__, %ifmerge.lr.ph ], [ %color2, %ifmerge ]
  %color2 = fadd <4 x float> %color.07, %0
  %indvar.next = add i32 %indvar, 1
  %exitcond = icmp eq i32 %indvar.next, %.pre
  br i1 %exitcond, label %loop-header.then_crit_edge, label %ifmerge
}

declare <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32, i32, i32) nounwind readnone

declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) nounwind

inductive variable:  %indvar = phi i32 [ %indvar.next, %ifmerge ], [ 0, %ifmerge.lr.ph ]
  trip count:        %.pre = load i32 addrspace(2)* @Count, align 4
  increment:         %indvar.next = add i32 %indvar, 1
  exit condition:    %exitcond = icmp eq i32 %indvar.next, %.pre
#### BEGIN COMPILER 0 INFO LOG ####
#### END COMPILER 0 INFO LOG ####
#### BEGIN LINKER INFO LOG ####
#### END LINKER INFO LOG ####

// LunarGOO(r722) output
#version 130
uniform int Count;
uniform vec4 bigColor;
in vec4 BaseColor;
const int const25_0 = 0;
vec4 color2;

void main()
{
    vec4 color_0_lcssa;
    int indvar;
    vec4 color_07;
    bool temp24 = Count > const25_0;
    color_0_lcssa = BaseColor;
    if (temp24) {
        indvar = const25_0;
        color_07 = BaseColor;
        for (indvar = 0; indvar < Count; ++indvar) {
            color2 = color_07 + bigColor;
            color_07 = color2;
        }
        
        color_0_lcssa = color2;
    }
    
    gl_FragColor = color_0_lcssa;
    
}
#### BEGIN COMPILER 0 INFO LOG ####
#### END COMPILER 0 INFO LOG ####
#### BEGIN LINKER INFO LOG ####
#### END LINKER INFO LOG ####

// LunarGOO(r722) output
#version 130
uniform int Count;
uniform vec4 bigColor;
const int const25_0 = 0;
in vec4 BaseColor;
vec4 color2;

void main()
{
    int indvar;
    vec4 color_07_014;
    vec4 color_0_lcssa_0;
    bool temp241 = Count > const25_0;
    color_0_lcssa_0 = BaseColor;
    if (temp241) {
        indvar = const25_0;
        color_07_014 = BaseColor;
        for (indvar = 0; indvar < Count; ++indvar) {
            color2 = color_07_014 + bigColor;
            color_07_014 = color2;
        }
        
        color_0_lcssa_0 = color2;
    }
    
    gl_FragColor = color_0_lcssa_0;
    
}
