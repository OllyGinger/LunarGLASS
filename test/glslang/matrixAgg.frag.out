
Top IR:
; ModuleID = 'Top'

%s = type { i32, [12 x [4 x <3 x float>]] }

@us = external addrspace(2) constant %s
@i = external addrspace(2) constant i32
@"matrix am" = external addrspace(2) constant [8 x [4 x <3 x float>]]
@FragColor_shadow = internal global <4 x float> zeroinitializer
@v_shadow = internal global <3 x float> zeroinitializer

define fastcc void @main() {
entry:
  %ls = alloca %s
  %0 = load i32 addrspace(2)* @i, !uniform !2
  %1 = getelementptr %s addrspace(2)* @us, i32 0, i32 1, i32 %0
  %2 = load [4 x <3 x float>] addrspace(2)* %1, !uniform !0
  %3 = load [4 x <3 x float>] addrspace(2)* getelementptr inbounds ([8 x [4 x <3 x float>]] addrspace(2)* @"matrix am", i32 0, i32 4), !uniform !3
  %4 = alloca [4 x <3 x float>]
  %5 = load [4 x <3 x float>]* %4
  %leftColumn = extractvalue [4 x <3 x float>] %2, 0
  %rightColumn = extractvalue [4 x <3 x float>] %3, 0
  %column = fadd <3 x float> %leftColumn, %rightColumn
  %6 = insertvalue [4 x <3 x float>] %5, <3 x float> %column, 0
  %leftColumn1 = extractvalue [4 x <3 x float>] %2, 1
  %rightColumn2 = extractvalue [4 x <3 x float>] %3, 1
  %column3 = fadd <3 x float> %leftColumn1, %rightColumn2
  %7 = insertvalue [4 x <3 x float>] %6, <3 x float> %column3, 1
  %leftColumn4 = extractvalue [4 x <3 x float>] %2, 2
  %rightColumn5 = extractvalue [4 x <3 x float>] %3, 2
  %column6 = fadd <3 x float> %leftColumn4, %rightColumn5
  %8 = insertvalue [4 x <3 x float>] %7, <3 x float> %column6, 2
  %leftColumn7 = extractvalue [4 x <3 x float>] %2, 3
  %rightColumn8 = extractvalue [4 x <3 x float>] %3, 3
  %column9 = fadd <3 x float> %leftColumn7, %rightColumn8
  %9 = insertvalue [4 x <3 x float>] %8, <3 x float> %column9, 3
  %10 = getelementptr %s* %ls, i32 0, i32 1, i32 3
  store [4 x <3 x float>] %9, [4 x <3 x float>]* %10
  %v__ = call <3 x float> @llvm.gla.fReadInterpolant.v3f32(i32 1024, i32 -1, i32 1), !input !6
  store <3 x float> %v__, <3 x float>* @v_shadow
  %11 = load <3 x float>* @v_shadow
  %12 = getelementptr %s* %ls, i32 0, i32 1, i32 3
  %13 = load [4 x <3 x float>]* %12
  %14 = alloca <4 x float>
  %15 = load <4 x float>* %14
  %column10 = extractvalue [4 x <3 x float>] %13, 0
  %dot = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %11, <3 x float> %column10)
  %16 = insertelement <4 x float> %15, float %dot, i32 0
  %column11 = extractvalue [4 x <3 x float>] %13, 1
  %dot12 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %11, <3 x float> %column11)
  %17 = insertelement <4 x float> %16, float %dot12, i32 1
  %column13 = extractvalue [4 x <3 x float>] %13, 2
  %dot14 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %11, <3 x float> %column13)
  %18 = insertelement <4 x float> %17, float %dot14, i32 2
  %column15 = extractvalue [4 x <3 x float>] %13, 3
  %dot16 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %11, <3 x float> %column15)
  %FragColor_shadow = insertelement <4 x float> %18, float %dot16, i32 3
  store <4 x float> %FragColor_shadow, <4 x float>* @FragColor_shadow
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %entry
  %19 = load <4 x float>* @FragColor_shadow
  call void @llvm.gla.fWriteData.v4f32(i32 0, i32 -1, <4 x float> %19), !output !5
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

declare <3 x float> @llvm.gla.fReadInterpolant.v3f32(i32, i32, i32) nounwind readnone

declare float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float>, <3 x float>) nounwind readnone

declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) nounwind

!defaultUniforms = !{!0, !2, !3}
!outputs = !{!5}
!inputs = !{!6}

!0 = metadata !{metadata !"us", i32 12, %s addrspace(2)* @us, metadata !1}
!1 = metadata !{i32 0, i32 0, i32 0}
!2 = metadata !{metadata !"i", i32 12, i32 addrspace(2)* @i, metadata !1}
!3 = metadata !{metadata !"am", i32 12, [8 x [4 x <3 x float>]] addrspace(2)* @"matrix am", metadata !4}
!4 = metadata !{i32 3, i32 0, i32 0}
!5 = metadata !{metadata !"gl_FragColor", i32 1, <4 x float>* @FragColor_shadow, metadata !1}
!6 = metadata !{metadata !"v", i32 7, <3 x float>* @v_shadow, metadata !7}
!7 = metadata !{i32 0, i32 0, i32 1024}


Bottom IR:
; ModuleID = 'Top'

%s = type { i32, [12 x [4 x <3 x float>]] }

@us = external addrspace(2) constant %s
@i = external addrspace(2) constant i32
@"matrix am" = external addrspace(2) constant [8 x [4 x <3 x float>]]

define fastcc void @main() {
entry:
  %0 = load i32 addrspace(2)* @i, align 4, !uniform !2
  %1 = getelementptr %s addrspace(2)* @us, i32 0, i32 1, i32 %0
  %2 = load [4 x <3 x float>] addrspace(2)* %1, align 16, !uniform !0
  %gla_constGEP = getelementptr [8 x [4 x <3 x float>]] addrspace(2)* @"matrix am", i32 0, i32 4
  %3 = load [4 x <3 x float>] addrspace(2)* %gla_constGEP, align 16, !uniform !3
  %v__ = call <3 x float> @llvm.gla.fReadInterpolant.v3f32(i32 1024, i32 -1, i32 1), !input !6
  %rightColumn = extractvalue [4 x <3 x float>] %3, 0
  %leftColumn = extractvalue [4 x <3 x float>] %2, 0
  %rightColumn2 = extractvalue [4 x <3 x float>] %3, 1
  %leftColumn1 = extractvalue [4 x <3 x float>] %2, 1
  %column = fadd <3 x float> %leftColumn, %rightColumn
  %dot = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v__, <3 x float> %column)
  %rightColumn5 = extractvalue [4 x <3 x float>] %3, 2
  %leftColumn4 = extractvalue [4 x <3 x float>] %2, 2
  %column3 = fadd <3 x float> %leftColumn1, %rightColumn2
  %dot12 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v__, <3 x float> %column3)
  %rightColumn8 = extractvalue [4 x <3 x float>] %3, 3
  %leftColumn7 = extractvalue [4 x <3 x float>] %2, 3
  %column6 = fadd <3 x float> %leftColumn4, %rightColumn5
  %dot14 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v__, <3 x float> %column6)
  %column9 = fadd <3 x float> %leftColumn7, %rightColumn8
  %dot16 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v__, <3 x float> %column9)
  %4 = call <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.f32.f32.f32.f32(<4 x float> undef, i32 15, float %dot, i32 0, float %dot12, i32 0, float %dot14, i32 0, float %dot16, i32 0)
  call void @llvm.gla.fWriteData.v4f32(i32 0, i32 -1, <4 x float> %4), !output !5
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %entry
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

declare <3 x float> @llvm.gla.fReadInterpolant.v3f32(i32, i32, i32) nounwind readnone

declare float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float>, <3 x float>) nounwind readnone

declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) nounwind

declare <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.f32.f32.f32.f32(<4 x float>, i32, float, i32, float, i32, float, i32, float, i32) nounwind readnone

!defaultUniforms = !{!0, !2, !3}
!outputs = !{!5}
!inputs = !{!6}

!0 = metadata !{metadata !"us", i32 12, %s addrspace(2)* @us, metadata !1}
!1 = metadata !{i32 0, i32 0, i32 0}
!2 = metadata !{metadata !"i", i32 12, i32 addrspace(2)* @i, metadata !1}
!3 = metadata !{metadata !"am", i32 12, [8 x [4 x <3 x float>]] addrspace(2)* @"matrix am", metadata !4}
!4 = metadata !{i32 3, i32 0, i32 0}
!5 = metadata !{metadata !"gl_FragColor", i32 1, null, metadata !1}
!6 = metadata !{metadata !"v", i32 7, null, metadata !7}
!7 = metadata !{i32 0, i32 0, i32 1024}
#### BEGIN COMPILER 0 INFO LOG ####
#### END COMPILER 0 INFO LOG ####
#### BEGIN LINKER INFO LOG ####
#### END LINKER INFO LOG ####

// LunarGOO(r722) output
#version 120
struct s {
    int member0;
    vec3[4][12] member1;
};

uniform s us;
uniform int i;
uniform mat4x3[8] am;
varying vec3 v;

void main()
{
    vec3[4] temp21 = us.member1[i];
    vec3[4] temp22 = am[4];
    vec3 rightColumn = temp22[0];
    vec3 leftColumn = temp21[0];
    vec3 rightColumn2 = temp22[1];
    vec3 leftColumn1 = temp21[1];
    vec3 column = leftColumn + rightColumn;
    float dot = dot(v, column);
    vec3 rightColumn5 = temp22[2];
    vec3 leftColumn4 = temp21[2];
    vec3 column3 = leftColumn1 + rightColumn2;
    float dot12 = dot(v, column3);
    vec3 rightColumn8 = temp22[3];
    vec3 leftColumn7 = temp21[3];
    vec3 column6 = leftColumn4 + rightColumn5;
    float dot14 = dot(v, column6);
    vec3 column9 = leftColumn7 + rightColumn8;
    float dot16 = dot(v, column9);
    vec4 temp39 = vec4(dot, dot12, dot14, dot16);
    gl_FragColor = temp39;
    
}
#### END COMPILER 0 INFO LOG ####
#### BEGIN LINKER INFO LOG ####
ERROR: Not all shaders have valid object code.
#### END LINKER INFO LOG ####
