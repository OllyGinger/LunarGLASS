
Top IR:
; ModuleID = 'Top'

@Position_shadow = internal global <4 x float> zeroinitializer
@m4 = external addrspace(2) constant [4 x <4 x float>]
@v3_shadow = internal global <3 x float> zeroinitializer
@m3 = external addrspace(2) constant [3 x <3 x float>]
@VertexID_shadow = internal global i32 0

define fastcc void @main() {
entry:
  %constructed = alloca <4 x float>
  %param5 = alloca <3 x float>
  %param4 = alloca [3 x <3 x float>]
  %param1 = alloca <3 x float>
  %param = alloca [4 x <4 x float>]
  %param2 = load [4 x <4 x float>] addrspace(2)* @m4, !gla.uniform !2
  store [4 x <4 x float>] %param2, [4 x <4 x float>]* %param
  %v3 = call <3 x float> @llvm.gla.fReadData.v3f32(i32 1025, i32 -1), !gla.input !5
  store <3 x float> %v3, <3 x float>* @v3_shadow
  %param13 = load <3 x float>* @v3_shadow
  store <3 x float> %param13, <3 x float>* %param1
  %0 = call <3 x float> @"mxv(mf44;vf3;"([4 x <4 x float>]* %param, <3 x float>* %param1)
  %param46 = load [3 x <3 x float>] addrspace(2)* @m3, !gla.uniform !4
  store [3 x <3 x float>] %param46, [3 x <3 x float>]* %param4
  %v37 = call <3 x float> @llvm.gla.fReadData.v3f32(i32 1025, i32 -1), !gla.input !5
  store <3 x float> %v37, <3 x float>* @v3_shadow
  %param58 = load <3 x float>* @v3_shadow
  store <3 x float> %param58, <3 x float>* %param5
  %1 = call <3 x float> @"xf(mf33;vf3;"([3 x <3 x float>]* %param4, <3 x float>* %param5)
  %2 = fadd <3 x float> %0, %1
  %3 = load <4 x float>* %constructed
  %4 = extractelement <3 x float> %2, i32 0
  %5 = insertelement <4 x float> %3, float %4, i32 0
  %6 = extractelement <3 x float> %2, i32 1
  %7 = insertelement <4 x float> %5, float %6, i32 1
  %8 = extractelement <3 x float> %2, i32 2
  %9 = insertelement <4 x float> %7, float %8, i32 2
  %Position_shadow = insertelement <4 x float> %9, float 1.000000e+00, i32 3
  store <4 x float> %Position_shadow, <4 x float>* @Position_shadow
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %entry
  %10 = load <4 x float>* @Position_shadow
  call void @llvm.gla.fWriteData.v4f32(i32 1024, i32 -1, <4 x float> %10), !gla.output !0
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

define internal fastcc <3 x float> @"xf(mf33;vf3;"([3 x <3 x float>]*, <3 x float>*) alwaysinline {
entry:
  %2 = load <3 x float>* %1
  %3 = load [3 x <3 x float>]* %0
  %4 = alloca <3 x float>
  %5 = load <3 x float>* %4
  %column = extractvalue [3 x <3 x float>] %3, 0
  %dot = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %column)
  %6 = insertelement <3 x float> %5, float %dot, i32 0
  %column1 = extractvalue [3 x <3 x float>] %3, 1
  %dot2 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %column1)
  %7 = insertelement <3 x float> %6, float %dot2, i32 1
  %column3 = extractvalue [3 x <3 x float>] %3, 2
  %dot4 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %column3)
  %8 = insertelement <3 x float> %7, float %dot4, i32 2
  ret <3 x float> %8

post-return:                                      ; No predecessors!
  unreachable
}

define internal fastcc [3 x <3 x float>] @"Mat3(mf44;"([4 x <4 x float>]*) alwaysinline {
entry:
  %constructed = alloca [3 x <3 x float>]
  %1 = getelementptr [4 x <4 x float>]* %0, i32 0, i32 0
  %2 = load <4 x float>* %1
  %3 = extractelement <4 x float> %2, i32 0
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %2, i32 1
  %6 = insertelement <3 x float> %4, float %5, i32 1
  %7 = extractelement <4 x float> %2, i32 2
  %8 = insertelement <3 x float> %6, float %7, i32 2
  %9 = getelementptr [4 x <4 x float>]* %0, i32 0, i32 1
  %10 = load <4 x float>* %9
  %11 = extractelement <4 x float> %10, i32 0
  %12 = insertelement <3 x float> undef, float %11, i32 0
  %13 = extractelement <4 x float> %10, i32 1
  %14 = insertelement <3 x float> %12, float %13, i32 1
  %15 = extractelement <4 x float> %10, i32 2
  %16 = insertelement <3 x float> %14, float %15, i32 2
  %17 = getelementptr [4 x <4 x float>]* %0, i32 0, i32 2
  %18 = load <4 x float>* %17
  %19 = extractelement <4 x float> %18, i32 0
  %20 = insertelement <3 x float> undef, float %19, i32 0
  %21 = extractelement <4 x float> %18, i32 1
  %22 = insertelement <3 x float> %20, float %21, i32 1
  %23 = extractelement <4 x float> %18, i32 2
  %24 = insertelement <3 x float> %22, float %23, i32 2
  %25 = load [3 x <3 x float>]* %constructed
  %element = extractelement <3 x float> %8, i32 0
  %element1 = extractelement <3 x float> %8, i32 1
  %element2 = extractelement <3 x float> %8, i32 2
  %element3 = extractelement <3 x float> %16, i32 0
  %element4 = extractelement <3 x float> %16, i32 1
  %element5 = extractelement <3 x float> %16, i32 2
  %element6 = extractelement <3 x float> %24, i32 0
  %element7 = extractelement <3 x float> %24, i32 1
  %element8 = extractelement <3 x float> %24, i32 2
  %column = extractvalue [3 x <3 x float>] %25, 0
  %column9 = insertelement <3 x float> %column, float %element, i32 0
  %column10 = insertelement <3 x float> %column9, float %element1, i32 1
  %column11 = insertelement <3 x float> %column10, float %element2, i32 2
  %matrix = insertvalue [3 x <3 x float>] %25, <3 x float> %column11, 0
  %column12 = extractvalue [3 x <3 x float>] %25, 1
  %column13 = insertelement <3 x float> %column12, float %element3, i32 0
  %column14 = insertelement <3 x float> %column13, float %element4, i32 1
  %column15 = insertelement <3 x float> %column14, float %element5, i32 2
  %matrix16 = insertvalue [3 x <3 x float>] %matrix, <3 x float> %column15, 1
  %column17 = extractvalue [3 x <3 x float>] %25, 2
  %column18 = insertelement <3 x float> %column17, float %element6, i32 0
  %column19 = insertelement <3 x float> %column18, float %element7, i32 1
  %column20 = insertelement <3 x float> %column19, float %element8, i32 2
  %matrix21 = insertvalue [3 x <3 x float>] %matrix16, <3 x float> %column20, 2
  ret [3 x <3 x float>] %matrix21

post-return:                                      ; No predecessors!
  unreachable
}

define internal fastcc <3 x float> @"mxv(mf44;vf3;"([4 x <4 x float>]*, <3 x float>*) alwaysinline {
entry:
  %param = alloca [4 x <4 x float>]
  %2 = load <3 x float>* %1
  %param1 = load [4 x <4 x float>]* %0
  store [4 x <4 x float>] %param1, [4 x <4 x float>]* %param
  %3 = call [3 x <3 x float>] @"Mat3(mf44;"([4 x <4 x float>]* %param)
  %4 = alloca <3 x float>
  %5 = load <3 x float>* %4
  %column = extractvalue [3 x <3 x float>] %3, 0
  %dot = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %column)
  %6 = insertelement <3 x float> %5, float %dot, i32 0
  %column2 = extractvalue [3 x <3 x float>] %3, 1
  %dot3 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %column2)
  %7 = insertelement <3 x float> %6, float %dot3, i32 1
  %column4 = extractvalue [3 x <3 x float>] %3, 2
  %dot5 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %column4)
  %8 = insertelement <3 x float> %7, float %dot5, i32 2
  ret <3 x float> %8

post-return:                                      ; No predecessors!
  unreachable
}

declare float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float>, <3 x float>) nounwind readnone

declare <3 x float> @llvm.gla.fReadData.v3f32(i32, i32) nounwind readonly

declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) nounwind

!gla.outputs = !{!0}
!gla.uniforms = !{!2, !4}
!gla.inputs = !{!5, !7}

!0 = metadata !{metadata !"gl_Position", i32 8, <4 x float>* @Position_shadow_typeProxy, metadata !1}
!1 = metadata !{i32 0, i32 0, i32 1024, null, i32 0}
!2 = metadata !{metadata !"m4", i32 12, [4 x <4 x float>]* @m4_typeProxy, metadata !3}
!3 = metadata !{i32 3, i32 0, i32 1024, null}
!4 = metadata !{metadata !"m3", i32 12, [3 x <3 x float>]* @m3_typeProxy, metadata !3}
!5 = metadata !{metadata !"v3", i32 1, <3 x float>* @v3_shadow_typeProxy, metadata !6}
!6 = metadata !{i32 0, i32 0, i32 1025, null, i32 0}
!7 = metadata !{metadata !"gl_VertexID", i32 2, i32* @VertexID_shadow_typeProxy, metadata !8}
!8 = metadata !{i32 0, i32 0, i32 1026, null, i32 0}


Bottom IR:
; ModuleID = 'Top'

@m4 = external addrspace(2) constant [4 x <4 x float>]
@m3 = external addrspace(2) constant [3 x <3 x float>]

define fastcc void @main() {
entry:
  %param2 = load [4 x <4 x float>] addrspace(2)* @m4, align 16, !gla.uniform !2
  %v3 = call <3 x float> @llvm.gla.fReadData.v3f32(i32 1025, i32 -1), !gla.input !5
  %param212 = extractvalue [4 x <4 x float>] %param2, 0
  %0 = call <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float> %param212, <3 x i32> <i32 0, i32 1, i32 2>)
  %param213 = extractvalue [4 x <4 x float>] %param2, 1
  %1 = call <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float> %param213, <3 x i32> <i32 0, i32 1, i32 2>)
  %param214 = extractvalue [4 x <4 x float>] %param2, 2
  %2 = call <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float> %param214, <3 x i32> <i32 0, i32 1, i32 2>)
  %dot.i = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3, <3 x float> %0)
  %dot3.i = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3, <3 x float> %1)
  %dot5.i = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3, <3 x float> %2)
  %3 = call <3 x float> @llvm.gla.fMultiInsert.v3f32.v3f32.f32.f32.f32.f32(<3 x float> undef, i32 7, float %dot.i, i32 0, float %dot3.i, i32 0, float %dot5.i, i32 0, float undef, i32 undef)
  %param46 = load [3 x <3 x float>] addrspace(2)* @m3, align 16, !gla.uniform !4
  %column.i10 = extractvalue [3 x <3 x float>] %param46, 0
  %dot.i11 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3, <3 x float> %column.i10)
  %column1.i = extractvalue [3 x <3 x float>] %param46, 1
  %dot2.i = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3, <3 x float> %column1.i)
  %column3.i = extractvalue [3 x <3 x float>] %param46, 2
  %dot4.i = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3, <3 x float> %column3.i)
  %4 = call <3 x float> @llvm.gla.fMultiInsert.v3f32.v3f32.f32.f32.f32.f32(<3 x float> undef, i32 7, float %dot.i11, i32 0, float %dot2.i, i32 0, float %dot4.i, i32 0, float undef, i32 undef)
  %5 = fadd <3 x float> %3, %4
  %6 = call <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.v3f32.v3f32.v3f32.f32(<4 x float> undef, i32 15, <3 x float> %5, i32 0, <3 x float> %5, i32 1, <3 x float> %5, i32 2, float 1.000000e+00, i32 0)
  call void @llvm.gla.fWriteData.v4f32(i32 1024, i32 -1, <4 x float> %6), !gla.output !0
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %entry
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

declare float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float>, <3 x float>) nounwind readnone

declare <3 x float> @llvm.gla.fReadData.v3f32(i32, i32) nounwind readonly

declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) nounwind

declare <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.v3f32.v3f32.v3f32.f32(<4 x float>, i32, <3 x float>, i32, <3 x float>, i32, <3 x float>, i32, float, i32) nounwind readnone

declare <3 x float> @llvm.gla.fMultiInsert.v3f32.v3f32.f32.f32.f32.f32(<3 x float>, i32, float, i32, float, i32, float, i32, float, i32) nounwind readnone

declare <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float>, <3 x i32>) nounwind readnone

!gla.outputs = !{!0}
!gla.uniforms = !{!2, !4}
!gla.inputs = !{!5, !7}

!0 = metadata !{metadata !"gl_Position", i32 8, <4 x float>* @Position_shadow_typeProxy, metadata !1}
!1 = metadata !{i32 0, i32 0, i32 1024, null, i32 0}
!2 = metadata !{metadata !"m4", i32 12, [4 x <4 x float>]* @m4_typeProxy, metadata !3}
!3 = metadata !{i32 3, i32 0, i32 1024, null}
!4 = metadata !{metadata !"m3", i32 12, [3 x <3 x float>]* @m3_typeProxy, metadata !3}
!5 = metadata !{metadata !"v3", i32 1, <3 x float>* @v3_shadow_typeProxy, metadata !6}
!6 = metadata !{i32 0, i32 0, i32 1025, null, i32 0}
!7 = metadata !{metadata !"gl_VertexID", i32 2, i32* @VertexID_shadow_typeProxy, metadata !8}
!8 = metadata !{i32 0, i32 0, i32 1026, null, i32 0}
#### BEGIN COMPILER 0 INFO LOG ####
#### END COMPILER 0 INFO LOG ####
#### BEGIN LINKER INFO LOG ####
#### END LINKER INFO LOG ####
#version 130
// LunarGOO output (r722)
uniform mat4 m4;
uniform mat3 m3;
in vec3 v3;
const float const40 = 1.0;

void main()
{
    vec4 param212 = m4[0];
    vec3 temp22 = vec3(param212);
    vec4 param213 = m4[1];
    vec3 temp24 = vec3(param213);
    vec4 param214 = m4[2];
    vec3 temp26 = vec3(param214);
    float dotdi = dot(v3, temp22);
    float dot3di = dot(v3, temp24);
    float dot5di = dot(v3, temp26);
    vec3 temp30;
    temp30.xyz = vec3(dotdi, dot3di, dot5di);
    vec3 columndi10 = m3[0];
    float dotdi11 = dot(v3, columndi10);
    vec3 column1di = m3[1];
    float dot2di = dot(v3, column1di);
    vec3 column3di = m3[2];
    float dot4di = dot(v3, column3di);
    vec3 temp37;
    temp37.xyz = vec3(dotdi11, dot2di, dot4di);
    vec3 temp38 = temp30 + temp37;
    vec4 temp39 = vec4(temp38.x, temp38.y, temp38.z, const40);
    gl_Position = temp39;
    
}

#### BEGIN COMPILER 0 INFO LOG ####
#### END COMPILER 0 INFO LOG ####
#### BEGIN LINKER INFO LOG ####
#### END LINKER INFO LOG ####
#version 130
// LunarGOO output (r722)
uniform mat4 m4;
uniform mat3 m3;
in vec3 v3;
const float const40 = 1.0;

void main()
{
    vec4 param2121 = m4[0];
    vec3 temp22 = vec3(param2121);
    vec4 param2133 = m4[1];
    vec3 temp24 = vec3(param2133);
    vec4 param2146 = m4[2];
    vec3 temp26 = vec3(param2146);
    float dotdi9 = dot(v3, temp22);
    float dot3di11 = dot(v3, temp24);
    float dot5di13 = dot(v3, temp26);
    vec3 temp30;
    temp30.xyz = vec3(dotdi9, dot3di11, dot5di13);
    vec3 columndi1016 = m3[0];
    float dotdi1118 = dot(v3, columndi1016);
    vec3 column1di19 = m3[1];
    float dot2di21 = dot(v3, column1di19);
    vec3 column3di22 = m3[2];
    float dot4di24 = dot(v3, column3di22);
    vec3 temp37;
    temp37.xyz = vec3(dotdi1118, dot2di21, dot4di24);
    vec3 temp3827 = temp30 + temp37;
    vec4 temp39 = vec4(temp3827.x, temp3827.y, temp3827.z, const40);
    gl_Position = temp39;
    
}

