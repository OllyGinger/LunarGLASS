
Top IR:
; ModuleID = 'Top'

@Position_shadow = internal global <4 x float> zeroinitializer
@m4 = external addrspace(2) constant [4 x <4 x float>]
@v3_shadow = internal global <3 x float> zeroinitializer
@m3 = external addrspace(2) constant [3 x <3 x float>]

define fastcc void @main() {
entry:
  %constructed = alloca <4 x float>
  %param4 = alloca <3 x float>
  %param3 = alloca [3 x <3 x float>]
  %param1 = alloca <3 x float>
  %param = alloca [4 x <4 x float>]
  %__matrix = load [4 x <4 x float>] addrspace(2)* @m4
  store [4 x <4 x float>] %__matrix, [4 x <4 x float>]* %param
  %v3__ = call <3 x float> @llvm.gla.fReadInterpolant.v3f32(i32 0, i32 -1, i32 1)
  store <3 x float> %v3__, <3 x float>* @v3_shadow
  %param12 = load <3 x float>* @v3_shadow
  store <3 x float> %param12, <3 x float>* %param1
  %0 = call <3 x float> @"mxv(mf44;vf3;"([4 x <4 x float>]* %param, <3 x float>* %param1)
  %__matrix5 = load [3 x <3 x float>] addrspace(2)* @m3
  store [3 x <3 x float>] %__matrix5, [3 x <3 x float>]* %param3
  %v3__6 = call <3 x float> @llvm.gla.fReadInterpolant.v3f32(i32 0, i32 -1, i32 1)
  store <3 x float> %v3__6, <3 x float>* @v3_shadow
  %param47 = load <3 x float>* @v3_shadow
  store <3 x float> %param47, <3 x float>* %param4
  %1 = call <3 x float> @"xf(mf33;vf3;"([3 x <3 x float>]* %param3, <3 x float>* %param4)
  %2 = fadd <3 x float> %0, %1
  %3 = load <4 x float>* %constructed
  %4 = extractelement <3 x float> %2, i32 0
  %5 = insertelement <4 x float> %3, float %4, i32 0
  %6 = extractelement <3 x float> %2, i32 1
  %7 = insertelement <4 x float> %5, float %6, i32 1
  %8 = extractelement <3 x float> %2, i32 2
  %9 = insertelement <4 x float> %7, float %8, i32 2
  %Position_shadow = insertelement <4 x float> %9, float 1.000000e+00, i32 3
  store <4 x float> %Position_shadow, <4 x float>* @Position_shadow
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %entry
  %10 = load <4 x float>* @Position_shadow
  call void @llvm.gla.fWriteData.v4f32(i32 0, i32 -1, <4 x float> %10)
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

define internal fastcc <3 x float> @"xf(mf33;vf3;"([3 x <3 x float>]*, <3 x float>*) alwaysinline {
entry:
  %2 = load <3 x float>* %1
  %__matrix = load [3 x <3 x float>]* %0
  %3 = alloca <3 x float>
  %4 = load <3 x float>* %3
  %__column = extractvalue [3 x <3 x float>] %__matrix, 0
  %__dot = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %__column)
  %5 = insertelement <3 x float> %4, float %__dot, i32 0
  %__column1 = extractvalue [3 x <3 x float>] %__matrix, 1
  %__dot2 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %__column1)
  %6 = insertelement <3 x float> %5, float %__dot2, i32 1
  %__column3 = extractvalue [3 x <3 x float>] %__matrix, 2
  %__dot4 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %__column3)
  %7 = insertelement <3 x float> %6, float %__dot4, i32 2
  ret <3 x float> %7

post-return:                                      ; No predecessors!
  unreachable
}

declare float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float>, <3 x float>) nounwind readnone

define internal fastcc [3 x <3 x float>] @"Mat3(mf44;"([4 x <4 x float>]*) alwaysinline {
entry:
  %constructed = alloca [3 x <3 x float>]
  %1 = getelementptr [4 x <4 x float>]* %0, i32 0, i32 0
  %2 = load <4 x float>* %1
  %3 = extractelement <4 x float> %2, i32 0
  %4 = insertelement <3 x float> undef, float %3, i32 0
  %5 = extractelement <4 x float> %2, i32 1
  %6 = insertelement <3 x float> %4, float %5, i32 1
  %7 = extractelement <4 x float> %2, i32 2
  %8 = insertelement <3 x float> %6, float %7, i32 2
  %9 = getelementptr [4 x <4 x float>]* %0, i32 0, i32 1
  %10 = load <4 x float>* %9
  %11 = extractelement <4 x float> %10, i32 0
  %12 = insertelement <3 x float> undef, float %11, i32 0
  %13 = extractelement <4 x float> %10, i32 1
  %14 = insertelement <3 x float> %12, float %13, i32 1
  %15 = extractelement <4 x float> %10, i32 2
  %16 = insertelement <3 x float> %14, float %15, i32 2
  %17 = getelementptr [4 x <4 x float>]* %0, i32 0, i32 2
  %18 = load <4 x float>* %17
  %19 = extractelement <4 x float> %18, i32 0
  %20 = insertelement <3 x float> undef, float %19, i32 0
  %21 = extractelement <4 x float> %18, i32 1
  %22 = insertelement <3 x float> %20, float %21, i32 1
  %23 = extractelement <4 x float> %18, i32 2
  %24 = insertelement <3 x float> %22, float %23, i32 2
  %__matrix = load [3 x <3 x float>]* %constructed
  %__element = extractelement <3 x float> %8, i32 0
  %__element1 = extractelement <3 x float> %8, i32 1
  %__element2 = extractelement <3 x float> %8, i32 2
  %__element3 = extractelement <3 x float> %16, i32 0
  %__element4 = extractelement <3 x float> %16, i32 1
  %__element5 = extractelement <3 x float> %16, i32 2
  %__element6 = extractelement <3 x float> %24, i32 0
  %__element7 = extractelement <3 x float> %24, i32 1
  %__element8 = extractelement <3 x float> %24, i32 2
  %__column = extractvalue [3 x <3 x float>] %__matrix, 0
  %__column9 = insertelement <3 x float> %__column, float %__element, i32 0
  %__column10 = insertelement <3 x float> %__column9, float %__element1, i32 1
  %__column11 = insertelement <3 x float> %__column10, float %__element2, i32 2
  %__matrix12 = insertvalue [3 x <3 x float>] %__matrix, <3 x float> %__column11, 0
  %__column13 = extractvalue [3 x <3 x float>] %__matrix, 1
  %__column14 = insertelement <3 x float> %__column13, float %__element3, i32 0
  %__column15 = insertelement <3 x float> %__column14, float %__element4, i32 1
  %__column16 = insertelement <3 x float> %__column15, float %__element5, i32 2
  %__matrix17 = insertvalue [3 x <3 x float>] %__matrix12, <3 x float> %__column16, 1
  %__column18 = extractvalue [3 x <3 x float>] %__matrix, 2
  %__column19 = insertelement <3 x float> %__column18, float %__element6, i32 0
  %__column20 = insertelement <3 x float> %__column19, float %__element7, i32 1
  %__column21 = insertelement <3 x float> %__column20, float %__element8, i32 2
  %__matrix22 = insertvalue [3 x <3 x float>] %__matrix17, <3 x float> %__column21, 2
  ret [3 x <3 x float>] %__matrix22

post-return:                                      ; No predecessors!
  unreachable
}

define internal fastcc <3 x float> @"mxv(mf44;vf3;"([4 x <4 x float>]*, <3 x float>*) alwaysinline {
entry:
  %param = alloca [4 x <4 x float>]
  %2 = load <3 x float>* %1
  %__matrix = load [4 x <4 x float>]* %0
  store [4 x <4 x float>] %__matrix, [4 x <4 x float>]* %param
  %3 = call [3 x <3 x float>] @"Mat3(mf44;"([4 x <4 x float>]* %param)
  %4 = alloca <3 x float>
  %5 = load <3 x float>* %4
  %__column = extractvalue [3 x <3 x float>] %3, 0
  %__dot = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %__column)
  %6 = insertelement <3 x float> %5, float %__dot, i32 0
  %__column1 = extractvalue [3 x <3 x float>] %3, 1
  %__dot2 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %__column1)
  %7 = insertelement <3 x float> %6, float %__dot2, i32 1
  %__column3 = extractvalue [3 x <3 x float>] %3, 2
  %__dot4 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %2, <3 x float> %__column3)
  %8 = insertelement <3 x float> %7, float %__dot4, i32 2
  ret <3 x float> %8

post-return:                                      ; No predecessors!
  unreachable
}

declare <3 x float> @llvm.gla.fReadInterpolant.v3f32(i32, i32, i32) nounwind readnone

declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) nounwind


Bottom IR:
; ModuleID = 'Top'

@m4 = external addrspace(2) constant [4 x <4 x float>]
@m3 = external addrspace(2) constant [3 x <3 x float>]

define fastcc void @main() {
entry:
  %__matrix = load [4 x <4 x float>] addrspace(2)* @m4, align 16
  %v3__ = call <3 x float> @llvm.gla.fReadInterpolant.v3f32(i32 0, i32 -1, i32 1)
  %__matrix16 = extractvalue [4 x <4 x float>] %__matrix, 0
  %0 = call <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float> %__matrix16, <3 x i32> <i32 0, i32 1, i32 2>)
  %__matrix17 = extractvalue [4 x <4 x float>] %__matrix, 1
  %1 = call <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float> %__matrix17, <3 x i32> <i32 0, i32 1, i32 2>)
  %__matrix18 = extractvalue [4 x <4 x float>] %__matrix, 2
  %2 = call <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float> %__matrix18, <3 x i32> <i32 0, i32 1, i32 2>)
  %__dot.i = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3__, <3 x float> %0)
  %__dot2.i = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3__, <3 x float> %1)
  %__dot4.i = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3__, <3 x float> %2)
  %3 = call <3 x float> @llvm.gla.fMultiInsert.v3f32.v3f32.f32.f32.f32.f32(<3 x float> undef, i32 7, float %__dot.i, i32 0, float %__dot2.i, i32 0, float %__dot4.i, i32 0, float undef, i32 undef)
  %__matrix5 = load [3 x <3 x float>] addrspace(2)* @m3, align 16
  %__column.i10 = extractvalue [3 x <3 x float>] %__matrix5, 0
  %__dot.i11 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3__, <3 x float> %__column.i10)
  %__column1.i12 = extractvalue [3 x <3 x float>] %__matrix5, 1
  %__dot2.i13 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3__, <3 x float> %__column1.i12)
  %__column3.i14 = extractvalue [3 x <3 x float>] %__matrix5, 2
  %__dot4.i15 = call float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float> %v3__, <3 x float> %__column3.i14)
  %4 = call <3 x float> @llvm.gla.fMultiInsert.v3f32.v3f32.f32.f32.f32.f32(<3 x float> undef, i32 7, float %__dot.i11, i32 0, float %__dot2.i13, i32 0, float %__dot4.i15, i32 0, float undef, i32 undef)
  %5 = fadd <3 x float> %3, %4
  %6 = call <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.v3f32.v3f32.v3f32.f32(<4 x float> undef, i32 15, <3 x float> %5, i32 0, <3 x float> %5, i32 1, <3 x float> %5, i32 2, float 1.000000e+00, i32 0)
  call void @llvm.gla.fWriteData.v4f32(i32 0, i32 -1, <4 x float> %6)
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %entry
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

declare float @llvm.gla.fDot3.f32.v3f32.v3f32(<3 x float>, <3 x float>) nounwind readnone

declare <3 x float> @llvm.gla.fReadInterpolant.v3f32(i32, i32, i32) nounwind readnone

declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) nounwind

declare <4 x float> @llvm.gla.fMultiInsert.v4f32.v4f32.v3f32.v3f32.v3f32.f32(<4 x float>, i32, <3 x float>, i32, <3 x float>, i32, <3 x float>, i32, float, i32) nounwind readnone

declare <3 x float> @llvm.gla.fMultiInsert.v3f32.v3f32.f32.f32.f32.f32(<3 x float>, i32, float, i32, float, i32, float, i32, float, i32) nounwind readnone

declare <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float>, <3 x i32>) nounwind readnone
#### BEGIN COMPILER 0 INFO LOG ####
#### END COMPILER 0 INFO LOG ####
#### BEGIN LINKER INFO LOG ####
#### END LINKER INFO LOG ####

// LunarGOO(r722) output
#version 130
uniform vec4[4] m4;
uniform vec3[3] m3;
in vec3 v3;
const float const40_1f = 1.0;

void main()
{
    vec4 __matrix16 = m4[0];
    vec3 temp22 = vec3(__matrix16);
    vec4 __matrix17 = m4[1];
    vec3 temp24 = vec3(__matrix17);
    vec4 __matrix18 = m4[2];
    vec3 temp26 = vec3(__matrix18);
    float __dot_i = dot(v3, temp22);
    float __dot2_i = dot(v3, temp24);
    float __dot4_i = dot(v3, temp26);
    vec3 temp30;
    temp30.xyz = vec3(__dot_i, __dot2_i, __dot4_i);
    vec3 __column_i10 = m3[0];
    float __dot_i11 = dot(v3, __column_i10);
    vec3 __column1_i12 = m3[1];
    float __dot2_i13 = dot(v3, __column1_i12);
    vec3 __column3_i14 = m3[2];
    float __dot4_i15 = dot(v3, __column3_i14);
    vec3 temp37;
    temp37.xyz = vec3(__dot_i11, __dot2_i13, __dot4_i15);
    vec3 temp38 = temp30 + temp37;
    vec4 temp39 = vec4(temp38.x, temp38.y, temp38.z, const40_1f);
    gl_Position = temp39;
    
}
WARNING: 0:27: Two consecutive underscores are reserved for future use.
#### END COMPILER 0 INFO LOG ####
#### BEGIN LINKER INFO LOG ####
#### END LINKER INFO LOG ####

// LunarGOO(r722) output
#version 130
uniform vec4[4] m4;
uniform vec3[3] m3;
in vec3 v3;
const float const40_1f = 1.0;

void main()
{
    vec4 __matrix161 = m4[0];
    vec3 temp22 = vec3(__matrix161);
    vec4 __matrix173 = m4[1];
    vec3 temp24 = vec3(__matrix173);
    vec4 __matrix186 = m4[2];
    vec3 temp26 = vec3(__matrix186);
    float __dot_i9 = dot(v3, temp22);
    float __dot2_i11 = dot(v3, temp24);
    float __dot4_i13 = dot(v3, temp26);
    vec3 temp30;
    temp30.xyz = vec3(__dot_i9, __dot2_i11, __dot4_i13);
    vec3 __column_i1016 = m3[0];
    float __dot_i1118 = dot(v3, __column_i1016);
    vec3 __column1_i1219 = m3[1];
    float __dot2_i1321 = dot(v3, __column1_i1219);
    vec3 __column3_i1422 = m3[2];
    float __dot4_i1524 = dot(v3, __column3_i1422);
    vec3 temp37;
    temp37.xyz = vec3(__dot_i1118, __dot2_i1321, __dot4_i1524);
    vec3 temp3827 = temp30 + temp37;
    vec4 temp39 = vec4(temp3827.x, temp3827.y, temp3827.z, const40_1f);
    gl_Position = temp39;
    
}
