
Top IR:
; ModuleID = 'Top'

%s1 = type { i32, float }
%s2 = type { i32, float, %s1 }

@foo2a = external addrspace(2) constant %s2
@foo2b = external addrspace(2) constant %s2
@"sampler2D sampler" = external addrspace(1) constant i32
@gl_FragColor = internal global <4 x float> zeroinitializer

define fastcc void @main() {
entry:
  %v = alloca <4 x float>
  %constructed12 = alloca [3 x %s1]
  %constructed11 = alloca %s1
  %constructed8 = alloca %s1
  %b = alloca [3 x %s1]
  %constructed5 = alloca [3 x %s1]
  %constructed4 = alloca %s1
  %constructed = alloca %s1
  %a = alloca [3 x %s1]
  %u = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 0, i32 -1, i32 1)
  %0 = extractelement <4 x float> %u, i32 0
  %1 = fptosi float %0 to i32
  %u1 = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 0, i32 -1, i32 1)
  %2 = extractelement <4 x float> %u1, i32 1
  %3 = getelementptr %s1* %constructed, i32 0, i32 0
  store i32 %1, i32* %3
  %4 = getelementptr %s1* %constructed, i32 0, i32 1
  store float %2, float* %4
  %5 = load %s1* %constructed
  %u2 = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 0, i32 -1, i32 1)
  %6 = extractelement <4 x float> %u2, i32 2
  %7 = fptosi float %6 to i32
  %u3 = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 0, i32 -1, i32 1)
  %8 = extractelement <4 x float> %u3, i32 3
  %9 = getelementptr %s1* %constructed4, i32 0, i32 0
  store i32 %7, i32* %9
  %10 = getelementptr %s1* %constructed4, i32 0, i32 1
  store float %8, float* %10
  %11 = load %s1* %constructed4
  %12 = getelementptr [3 x %s1]* %constructed5, i32 0, i32 0
  store %s1 %5, %s1* %12
  %13 = getelementptr [3 x %s1]* %constructed5, i32 0, i32 1
  store %s1 %11, %s1* %13
  %14 = getelementptr [3 x %s1]* %constructed5, i32 0, i32 2
  store %s1 { i32 14, float 1.400000e+01 }, %s1* %14
  %a6 = load [3 x %s1]* %constructed5
  store [3 x %s1] %a6, [3 x %s1]* %a
  %w = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 1, i32 -1, i32 1)
  %15 = extractelement <4 x float> %w, i32 0
  %16 = fptosi float %15 to i32
  %w7 = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 1, i32 -1, i32 1)
  %17 = extractelement <4 x float> %w7, i32 1
  %18 = getelementptr %s1* %constructed8, i32 0, i32 0
  store i32 %16, i32* %18
  %19 = getelementptr %s1* %constructed8, i32 0, i32 1
  store float %17, float* %19
  %20 = load %s1* %constructed8
  %w9 = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 1, i32 -1, i32 1)
  %21 = extractelement <4 x float> %w9, i32 2
  %22 = fptosi float %21 to i32
  %w10 = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 1, i32 -1, i32 1)
  %23 = extractelement <4 x float> %w10, i32 3
  %24 = getelementptr %s1* %constructed11, i32 0, i32 0
  store i32 %22, i32* %24
  %25 = getelementptr %s1* %constructed11, i32 0, i32 1
  store float %23, float* %25
  %26 = load %s1* %constructed11
  %27 = getelementptr [3 x %s1]* %constructed12, i32 0, i32 0
  store %s1 { i32 17, float 1.700000e+01 }, %s1* %27
  %28 = getelementptr [3 x %s1]* %constructed12, i32 0, i32 1
  store %s1 %20, %s1* %28
  %29 = getelementptr [3 x %s1]* %constructed12, i32 0, i32 2
  store %s1 %26, %s1* %29
  %b13 = load [3 x %s1]* %constructed12
  store [3 x %s1] %b13, [3 x %s1]* %b
  %30 = load %s2 addrspace(2)* @foo2a
  %31 = load %s2 addrspace(2)* @foo2b
  %element1 = extractvalue %s2 %30, 0
  %element2 = extractvalue %s2 %31, 0
  %32 = icmp eq i32 %element1, %element2
  %element114 = extractvalue %s2 %30, 1
  %element215 = extractvalue %s2 %31, 1
  %33 = fcmp oeq float %element114, %element215
  %34 = and i1 %32, %33
  %element116 = extractvalue %s2 %30, 2
  %element217 = extractvalue %s2 %31, 2
  %element118 = extractvalue %s1 %element116, 0
  %element219 = extractvalue %s1 %element217, 0
  %35 = icmp eq i32 %element118, %element219
  %element120 = extractvalue %s1 %element116, 1
  %element221 = extractvalue %s1 %element217, 1
  %36 = fcmp oeq float %element120, %element221
  %37 = and i1 %35, %36
  %38 = and i1 %34, %37
  br i1 %38, label %then, label %else

then:                                             ; preds = %entry
  %39 = load i32 addrspace(1)* @"sampler2D sampler"
  %coord = call <2 x float> @llvm.gla.fReadInterpolant.v2f32(i32 2, i32 -1, i32 1)
  %v22 = call <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32 2, i32 %39, i32 0, <2 x float> %coord)
  store <4 x float> %v22, <4 x float>* %v
  br label %ifmerge

else:                                             ; preds = %entry
  %40 = load i32 addrspace(1)* @"sampler2D sampler"
  %coord23 = call <2 x float> @llvm.gla.fReadInterpolant.v2f32(i32 2, i32 -1, i32 1)
  %41 = fmul <2 x float> <float 2.000000e+00, float 2.000000e+00>, %coord23
  %v24 = call <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32 2, i32 %40, i32 0, <2 x float> %41)
  store <4 x float> %v24, <4 x float>* %v
  br label %ifmerge

ifmerge:                                          ; preds = %else, %then
  %u25 = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 0, i32 -1, i32 1)
  %42 = load <4 x float>* %v
  %43 = fcmp oeq <4 x float> %u25, %42
  %44 = call i1 @llvm.gla.all.v4i1(<4 x i1> %43)
  br i1 %44, label %then26, label %ifmerge28

then26:                                           ; preds = %ifmerge
  %45 = load <4 x float>* %v
  %v27 = fmul <4 x float> %45, <float 3.000000e+00, float 3.000000e+00, float 3.000000e+00, float 3.000000e+00>
  store <4 x float> %v27, <4 x float>* %v
  br label %ifmerge28

ifmerge28:                                        ; preds = %ifmerge, %then26
  %u29 = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 0, i32 -1, i32 1)
  %46 = load <4 x float>* %v
  %47 = fcmp one <4 x float> %u29, %46
  %48 = call i1 @llvm.gla.any.v4i1(<4 x i1> %47)
  br i1 %48, label %then30, label %ifmerge32

then30:                                           ; preds = %ifmerge28
  %49 = load <4 x float>* %v
  %v31 = fmul <4 x float> %49, <float 4.000000e+00, float 4.000000e+00, float 4.000000e+00, float 4.000000e+00>
  store <4 x float> %v31, <4 x float>* %v
  br label %ifmerge32

ifmerge32:                                        ; preds = %ifmerge28, %then30
  %coord33 = call <2 x float> @llvm.gla.fReadInterpolant.v2f32(i32 2, i32 -1, i32 1)
  %50 = load <4 x float>* %v
  %51 = extractelement <4 x float> %50, i32 1
  %52 = insertelement <2 x float> undef, float %51, i32 0
  %53 = extractelement <4 x float> %50, i32 3
  %54 = insertelement <2 x float> %52, float %53, i32 1
  %55 = fcmp oeq <2 x float> %coord33, %54
  %56 = call i1 @llvm.gla.all.v2i1(<2 x i1> %55)
  br i1 %56, label %then34, label %ifmerge36

then34:                                           ; preds = %ifmerge32
  %57 = load <4 x float>* %v
  %v35 = fmul <4 x float> %57, <float 5.000000e+00, float 5.000000e+00, float 5.000000e+00, float 5.000000e+00>
  store <4 x float> %v35, <4 x float>* %v
  br label %ifmerge36

ifmerge36:                                        ; preds = %ifmerge32, %then34
  %58 = load [3 x %s1]* %a
  %59 = load [3 x %s1]* %b
  %element137 = extractvalue [3 x %s1] %58, 0
  %element238 = extractvalue [3 x %s1] %59, 0
  %element139 = extractvalue %s1 %element137, 0
  %element240 = extractvalue %s1 %element238, 0
  %60 = icmp eq i32 %element139, %element240
  %element141 = extractvalue %s1 %element137, 1
  %element242 = extractvalue %s1 %element238, 1
  %61 = fcmp oeq float %element141, %element242
  %62 = and i1 %60, %61
  %element143 = extractvalue [3 x %s1] %58, 1
  %element244 = extractvalue [3 x %s1] %59, 1
  %element145 = extractvalue %s1 %element143, 0
  %element246 = extractvalue %s1 %element244, 0
  %63 = icmp eq i32 %element145, %element246
  %element147 = extractvalue %s1 %element143, 1
  %element248 = extractvalue %s1 %element244, 1
  %64 = fcmp oeq float %element147, %element248
  %65 = and i1 %63, %64
  %66 = and i1 %62, %65
  %element149 = extractvalue [3 x %s1] %58, 2
  %element250 = extractvalue [3 x %s1] %59, 2
  %element151 = extractvalue %s1 %element149, 0
  %element252 = extractvalue %s1 %element250, 0
  %67 = icmp eq i32 %element151, %element252
  %element153 = extractvalue %s1 %element149, 1
  %element254 = extractvalue %s1 %element250, 1
  %68 = fcmp oeq float %element153, %element254
  %69 = and i1 %67, %68
  %70 = and i1 %66, %69
  br i1 %70, label %then55, label %ifmerge57

then55:                                           ; preds = %ifmerge36
  %71 = load <4 x float>* %v
  %v56 = fmul <4 x float> %71, <float 6.000000e+00, float 6.000000e+00, float 6.000000e+00, float 6.000000e+00>
  store <4 x float> %v56, <4 x float>* %v
  br label %ifmerge57

ifmerge57:                                        ; preds = %ifmerge36, %then55
  %72 = load [3 x %s1]* %a
  %73 = load [3 x %s1]* %b
  %element158 = extractvalue [3 x %s1] %72, 0
  %element259 = extractvalue [3 x %s1] %73, 0
  %element160 = extractvalue %s1 %element158, 0
  %element261 = extractvalue %s1 %element259, 0
  %74 = icmp ne i32 %element160, %element261
  %element162 = extractvalue %s1 %element158, 1
  %element263 = extractvalue %s1 %element259, 1
  %75 = fcmp one float %element162, %element263
  %76 = or i1 %74, %75
  %element164 = extractvalue [3 x %s1] %72, 1
  %element265 = extractvalue [3 x %s1] %73, 1
  %element166 = extractvalue %s1 %element164, 0
  %element267 = extractvalue %s1 %element265, 0
  %77 = icmp ne i32 %element166, %element267
  %element168 = extractvalue %s1 %element164, 1
  %element269 = extractvalue %s1 %element265, 1
  %78 = fcmp one float %element168, %element269
  %79 = or i1 %77, %78
  %80 = or i1 %76, %79
  %element170 = extractvalue [3 x %s1] %72, 2
  %element271 = extractvalue [3 x %s1] %73, 2
  %element172 = extractvalue %s1 %element170, 0
  %element273 = extractvalue %s1 %element271, 0
  %81 = icmp ne i32 %element172, %element273
  %element174 = extractvalue %s1 %element170, 1
  %element275 = extractvalue %s1 %element271, 1
  %82 = fcmp one float %element174, %element275
  %83 = or i1 %81, %82
  %84 = or i1 %80, %83
  br i1 %84, label %then76, label %ifmerge78

then76:                                           ; preds = %ifmerge57
  %85 = load <4 x float>* %v
  %v77 = fmul <4 x float> %85, <float 7.000000e+00, float 7.000000e+00, float 7.000000e+00, float 7.000000e+00>
  store <4 x float> %v77, <4 x float>* %v
  br label %ifmerge78

ifmerge78:                                        ; preds = %ifmerge57, %then76
  %gl_FragColor = load <4 x float>* %v
  store <4 x float> %gl_FragColor, <4 x float>* @gl_FragColor
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %ifmerge78
  %86 = load <4 x float>* @gl_FragColor
  call void @llvm.gla.fWriteData.v4f32(i32 0, i32 -1, <4 x float> %86)
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

declare <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32, i32, i32) nounwind readnone

declare <2 x float> @llvm.gla.fReadInterpolant.v2f32(i32, i32, i32) nounwind readnone

declare <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32, i32, i32, <2 x float>) nounwind readnone

declare i1 @llvm.gla.all.v4i1(<4 x i1>) nounwind readnone

declare i1 @llvm.gla.any.v4i1(<4 x i1>) nounwind readnone

declare i1 @llvm.gla.all.v2i1(<2 x i1>) nounwind readnone

declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) nounwind


Bottom IR:
; ModuleID = 'Top'

%s1 = type { i32, float }
%s2 = type { i32, float, %s1 }

@foo2a = external addrspace(2) constant %s2
@foo2b = external addrspace(2) constant %s2
@"sampler2D sampler" = external addrspace(1) constant i32

define fastcc void @main() {
entry:
  %u = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 0, i32 -1, i32 1)
  %0 = extractelement <4 x float> %u, i32 0
  %1 = fptosi float %0 to i32
  %2 = extractelement <4 x float> %u, i32 1
  %3 = extractelement <4 x float> %u, i32 2
  %4 = fptosi float %3 to i32
  %5 = extractelement <4 x float> %u, i32 3
  %w = call <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32 1, i32 -1, i32 1)
  %6 = extractelement <4 x float> %w, i32 0
  %7 = fptosi float %6 to i32
  %8 = extractelement <4 x float> %w, i32 1
  %9 = extractelement <4 x float> %w, i32 2
  %10 = fptosi float %9 to i32
  %11 = extractelement <4 x float> %w, i32 3
  %12 = load %s2 addrspace(2)* @foo2a, align 4
  %13 = load %s2 addrspace(2)* @foo2b, align 4
  %element1 = extractvalue %s2 %12, 0
  %element2 = extractvalue %s2 %13, 0
  %14 = icmp eq i32 %element1, %element2
  %element114 = extractvalue %s2 %12, 1
  %element215 = extractvalue %s2 %13, 1
  %15 = fcmp oeq float %element114, %element215
  %16 = and i1 %14, %15
  %element116 = extractvalue %s2 %12, 2
  %element217 = extractvalue %s2 %13, 2
  %element118 = extractvalue %s1 %element116, 0
  %element219 = extractvalue %s1 %element217, 0
  %17 = icmp eq i32 %element118, %element219
  %element120 = extractvalue %s1 %element116, 1
  %element221 = extractvalue %s1 %element217, 1
  %18 = fcmp oeq float %element120, %element221
  %19 = and i1 %17, %18
  %20 = and i1 %16, %19
  %21 = load i32 addrspace(1)* @"sampler2D sampler", align 4
  %coord = call <2 x float> @llvm.gla.fReadInterpolant.v2f32(i32 2, i32 -1, i32 1)
  br i1 %20, label %then, label %else

then:                                             ; preds = %entry
  %v22 = call <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32 2, i32 %21, i32 0, <2 x float> %coord)
  br label %ifmerge

else:                                             ; preds = %entry
  %22 = fmul <2 x float> %coord, <float 2.000000e+00, float 2.000000e+00>
  %v24 = call <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32 2, i32 %21, i32 0, <2 x float> %22)
  br label %ifmerge

ifmerge:                                          ; preds = %else, %then
  %v.0 = phi <4 x float> [ %v22, %then ], [ %v24, %else ]
  %23 = fcmp oeq <4 x float> %u, %v.0
  %24 = call i1 @llvm.gla.all.v4i1(<4 x i1> %23)
  %v27 = fmul <4 x float> %v.0, <float 3.000000e+00, float 3.000000e+00, float 3.000000e+00, float 3.000000e+00>
  %select139 = select i1 %24, <4 x float> %v27, <4 x float> %v.0
  %25 = fcmp one <4 x float> %u, %select139
  %26 = call i1 @llvm.gla.any.v4i1(<4 x i1> %25)
  %v31 = fmul <4 x float> %select139, <float 4.000000e+00, float 4.000000e+00, float 4.000000e+00, float 4.000000e+00>
  %select141 = select i1 %26, <4 x float> %v31, <4 x float> %select139
  %27 = call <2 x float> @llvm.gla.fSwizzle.v2f32.v4f32.v2i32(<4 x float> %select141, <2 x i32> <i32 1, i32 3>)
  %28 = fcmp oeq <2 x float> %coord, %27
  %29 = call i1 @llvm.gla.all.v2i1(<2 x i1> %28)
  %v35 = fmul <4 x float> %select141, <float 5.000000e+00, float 5.000000e+00, float 5.000000e+00, float 5.000000e+00>
  %select = select i1 %29, <4 x float> %v35, <4 x float> %select141
  %30 = icmp eq i32 %1, 17
  %31 = fcmp oeq float %2, 1.700000e+01
  %32 = and i1 %30, %31
  %33 = icmp eq i32 %4, %7
  %34 = fcmp oeq float %5, %8
  %35 = and i1 %33, %34
  %36 = and i1 %32, %35
  %37 = icmp eq i32 %10, 14
  %38 = fcmp oeq float %11, 1.400000e+01
  %39 = and i1 %37, %38
  %40 = and i1 %36, %39
  %v56 = fmul <4 x float> %select, <float 6.000000e+00, float 6.000000e+00, float 6.000000e+00, float 6.000000e+00>
  %select140 = select i1 %40, <4 x float> %v56, <4 x float> %select
  %41 = icmp ne i32 %1, 17
  %42 = fcmp one float %2, 1.700000e+01
  %43 = or i1 %41, %42
  %44 = icmp ne i32 %4, %7
  %45 = fcmp one float %5, %8
  %46 = or i1 %44, %45
  %47 = or i1 %43, %46
  %48 = icmp ne i32 %10, 14
  %49 = fcmp one float %11, 1.400000e+01
  %50 = or i1 %48, %49
  %51 = or i1 %47, %50
  %v77 = fmul <4 x float> %select140, <float 7.000000e+00, float 7.000000e+00, float 7.000000e+00, float 7.000000e+00>
  %select138 = select i1 %51, <4 x float> %v77, <4 x float> %select140
  call void @llvm.gla.fWriteData.v4f32(i32 0, i32 -1, <4 x float> %select138)
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %ifmerge
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

declare <4 x float> @llvm.gla.fReadInterpolant.v4f32(i32, i32, i32) nounwind readnone

declare <2 x float> @llvm.gla.fReadInterpolant.v2f32(i32, i32, i32) nounwind readnone

declare <4 x float> @llvm.gla.fTextureSample.v4f32.v2f32(i32, i32, i32, <2 x float>) nounwind readnone

declare i1 @llvm.gla.all.v4i1(<4 x i1>) nounwind readnone

declare i1 @llvm.gla.any.v4i1(<4 x i1>) nounwind readnone

declare i1 @llvm.gla.all.v2i1(<2 x i1>) nounwind readnone

declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) nounwind

declare <2 x float> @llvm.gla.fSwizzle.v2f32.v4f32.v2i32(<4 x float>, <2 x i32>) nounwind readnone

// LunarGOO(r471) output
#version 130
struct s1 {
    int member0;
    float member1;
};

struct s2 {
    int member0;
    float member1;
    s1 member2;
};

uniform s2 foo2a;
uniform s2 foo2b;
uniform sampler2D sampler;
in vec4 u;
in vec4 w;
in vec2 coord;
const vec2 const45 = vec2(2.0);
const vec4 const50 = vec4(3.0);
const vec4 const55 = vec4(4.0);
const vec4 const61 = vec4(5.0);
const int const64_17 = 17;
const float const66_17f = 17.0;
const int const73_14 = 14;
const float const75_14f = 14.0;
const vec4 const79 = vec4(6.0);
const vec4 const93 = vec4(7.0);

void main()
{
    vec4 v_0;
    int temp22 = int(u.x);
    int temp23 = int(u.z);
    int temp24 = int(w.x);
    int temp25 = int(w.z);
    int element1 = foo2a.member0;
    int element2 = foo2b.member0;
    bool temp28 = element1 == element2;
    float element114 = foo2a.member1;
    float element215 = foo2b.member1;
    bool temp31 = element114 == element215;
    bool temp32 = temp28 && temp31;
    s1 element116 = foo2a.member2;
    s1 element217 = foo2b.member2;
    int element118 = element116.member0;
    int element219 = element217.member0;
    bool temp37 = element118 == element219;
    float element120 = element116.member1;
    float element221 = element217.member1;
    bool temp40 = element120 == element221;
    bool temp41 = temp37 && temp40;
    bool temp42 = temp32 && temp41;
    if (temp42) {
        vec4 temp43 = texture2D(sampler, coord);
        v_0 = temp43;
    }
    else {
        vec2 temp44 = coord * const45;
        vec4 temp46 = texture2D(sampler, temp44);
        v_0 = temp46;
    }
    
    bvec4 temp47 = equal(u, v_0);
    bool temp48 = all(temp47);
    vec4 temp49 = v_0 * const50;
    vec4 select139 = temp48 ? temp49 : v_0;
    bvec4 temp52 = notEqual(u, select139);
    bool temp53 = any(temp52);
    vec4 temp54 = select139 * const55;
    vec4 select141 = temp53 ? temp54 : select139;
    vec2 temp57 = select141.yw;
    bvec2 temp58 = equal(coord, temp57);
    bool temp59 = all(temp58);
    vec4 temp60 = select141 * const61;
    vec4 select = temp59 ? temp60 : select141;
    bool temp63 = temp22 == const64_17;
    bool temp65 = u.y == const66_17f;
    bool temp67 = temp63 && temp65;
    bool temp68 = temp23 == temp24;
    bool temp69 = u.w == w.y;
    bool temp70 = temp68 && temp69;
    bool temp71 = temp67 && temp70;
    bool temp72 = temp25 == const73_14;
    bool temp74 = w.w == const75_14f;
    bool temp76 = temp72 && temp74;
    bool temp77 = temp71 && temp76;
    vec4 temp78 = select * const79;
    vec4 select140 = temp77 ? temp78 : select;
    bool temp81 = temp22 != const64_17;
    bool temp82 = u.y != const66_17f;
    bool temp83 = temp81 || temp82;
    bool temp84 = temp23 != temp24;
    bool temp85 = u.w != w.y;
    bool temp86 = temp84 || temp85;
    bool temp87 = temp83 || temp86;
    bool temp88 = temp25 != const73_14;
    bool temp89 = w.w != const75_14f;
    bool temp90 = temp88 || temp89;
    bool temp91 = temp87 || temp90;
    vec4 temp92 = select140 * const93;
    vec4 select138 = temp91 ? temp92 : select140;
    gl_FragColor = select138;
    
}
#### BEGIN COMPILER 0 INFO LOG ####

#### END COMPILER 0 INFO LOG ####
#### BEGIN LINKER INFO LOG ####

#### END LINKER INFO LOG ####
