
Top IR:
; ModuleID = 'Top'

@uv4 = external addrspace(2) constant <4 x float>
@ui = external addrspace(2) constant i32
@uf = external addrspace(2) constant float
@ub41 = external addrspace(2) constant <4 x i1>
@ub42 = external addrspace(2) constant <4 x i1>
@FragColor_shadow = internal global <4 x float> zeroinitializer

define fastcc void @main() {
entry:
  %constructed65 = alloca <4 x float>
  %constructed = alloca <4 x float>
  %ternary = alloca <4 x float>
  %f = alloca float
  %b = alloca i1
  %i = alloca i32
  %v = alloca <4 x float>
  %0 = load <4 x float> addrspace(2)* @uv4
  %v1 = call <4 x float> @llvm.gla.fRadians.v4f32.v4f32(<4 x float> %0)
  store <4 x float> %v1, <4 x float>* %v
  %1 = load <4 x float>* %v
  %2 = call <4 x float> @llvm.gla.fDegrees.v4f32.v4f32(<4 x float> %1)
  %3 = load <4 x float>* %v
  %v2 = fadd <4 x float> %3, %2
  store <4 x float> %v2, <4 x float>* %v
  %4 = load i32 addrspace(2)* @ui
  %5 = load i32 addrspace(2)* @ui
  %i3 = mul i32 %4, %5
  store i32 %i3, i32* %i
  %6 = load <4 x float>* %v
  %7 = call <4 x float> @llvm.gla.fSin.v4f32.v4f32(<4 x float> %6)
  %8 = load <4 x float>* %v
  %v4 = fadd <4 x float> %8, %7
  store <4 x float> %v4, <4 x float>* %v
  %9 = load <4 x float>* %v
  %10 = call <4 x float> @llvm.gla.fCos.v4f32.v4f32(<4 x float> %9)
  %11 = load <4 x float>* %v
  %v5 = fadd <4 x float> %11, %10
  store <4 x float> %v5, <4 x float>* %v
  %12 = load <4 x float>* %v
  %13 = call <4 x float> @llvm.gla.fTan.v4f32.v4f32(<4 x float> %12)
  %14 = load <4 x float>* %v
  %v6 = fadd <4 x float> %14, %13
  store <4 x float> %v6, <4 x float>* %v
  %15 = load <4 x float>* %v
  %16 = call <4 x float> @llvm.gla.fAsin.v4f32.v4f32(<4 x float> %15)
  %17 = load <4 x float>* %v
  %v7 = fadd <4 x float> %17, %16
  store <4 x float> %v7, <4 x float>* %v
  %18 = load <4 x float>* %v
  %19 = call <4 x float> @llvm.gla.fAcos.v4f32.v4f32(<4 x float> %18)
  %20 = load <4 x float>* %v
  %v8 = fadd <4 x float> %20, %19
  store <4 x float> %v8, <4 x float>* %v
  %21 = load <4 x float>* %v
  %22 = load <4 x float>* %v
  %23 = call <4 x float> @llvm.gla.fPow.v4f32.v4f32.v4f32(<4 x float> %21, <4 x float> %22)
  %24 = load <4 x float>* %v
  %v9 = fadd <4 x float> %24, %23
  store <4 x float> %v9, <4 x float>* %v
  %25 = load <4 x float>* %v
  %26 = call <4 x float> @llvm.gla.fExp.v4f32.v4f32(<4 x float> %25)
  %27 = load <4 x float>* %v
  %v10 = fadd <4 x float> %27, %26
  store <4 x float> %v10, <4 x float>* %v
  %28 = load <4 x float>* %v
  %29 = call <4 x float> @llvm.gla.fLog.v4f32.v4f32(<4 x float> %28)
  %30 = load <4 x float>* %v
  %v11 = fadd <4 x float> %30, %29
  store <4 x float> %v11, <4 x float>* %v
  %31 = load <4 x float>* %v
  %32 = call <4 x float> @llvm.gla.fExp2.v4f32.v4f32(<4 x float> %31)
  %33 = load <4 x float>* %v
  %v12 = fadd <4 x float> %33, %32
  store <4 x float> %v12, <4 x float>* %v
  %34 = load <4 x float>* %v
  %35 = call <4 x float> @llvm.gla.fLog2.v4f32.v4f32(<4 x float> %34)
  %36 = load <4 x float>* %v
  %v13 = fadd <4 x float> %36, %35
  store <4 x float> %v13, <4 x float>* %v
  %37 = load <4 x float>* %v
  %38 = call <4 x float> @llvm.gla.fSqrt.v4f32.v4f32(<4 x float> %37)
  %39 = load <4 x float>* %v
  %v14 = fadd <4 x float> %39, %38
  store <4 x float> %v14, <4 x float>* %v
  %40 = load <4 x float>* %v
  %41 = call <4 x float> @llvm.gla.fInverseSqrt.v4f32.v4f32(<4 x float> %40)
  %42 = load <4 x float>* %v
  %v15 = fadd <4 x float> %42, %41
  store <4 x float> %v15, <4 x float>* %v
  %43 = load <4 x float>* %v
  %44 = call <4 x float> @llvm.gla.fAbs.v4f32.v4f32(<4 x float> %43)
  %45 = load <4 x float>* %v
  %v16 = fadd <4 x float> %45, %44
  store <4 x float> %v16, <4 x float>* %v
  %46 = load <4 x float>* %v
  %47 = call <4 x float> @llvm.gla.fSign.v4f32.v4f32(<4 x float> %46)
  %48 = load <4 x float>* %v
  %v17 = fadd <4 x float> %48, %47
  store <4 x float> %v17, <4 x float>* %v
  %49 = load <4 x float>* %v
  %50 = call <4 x float> @llvm.gla.fFloor.v4f32.v4f32(<4 x float> %49)
  %51 = load <4 x float>* %v
  %v18 = fadd <4 x float> %51, %50
  store <4 x float> %v18, <4 x float>* %v
  %52 = load <4 x float>* %v
  %53 = call <4 x float> @llvm.gla.fCeiling.v4f32.v4f32(<4 x float> %52)
  %54 = load <4 x float>* %v
  %v19 = fadd <4 x float> %54, %53
  store <4 x float> %v19, <4 x float>* %v
  %55 = load <4 x float>* %v
  %56 = call <4 x float> @llvm.gla.fFraction.v4f32.v4f32(<4 x float> %55)
  %57 = load <4 x float>* %v
  %v20 = fadd <4 x float> %57, %56
  store <4 x float> %v20, <4 x float>* %v
  %58 = load <4 x float>* %v
  %59 = load <4 x float>* %v
  %60 = frem <4 x float> %58, %59
  %61 = load <4 x float>* %v
  %v21 = fadd <4 x float> %61, %60
  store <4 x float> %v21, <4 x float>* %v
  %62 = load <4 x float>* %v
  %63 = load <4 x float>* %v
  %64 = extractelement <4 x float> %63, i32 0
  %65 = insertelement <4 x float> undef, float %64, i32 0
  %66 = insertelement <4 x float> %65, float %64, i32 1
  %67 = insertelement <4 x float> %66, float %64, i32 2
  %68 = insertelement <4 x float> %67, float %64, i32 3
  %69 = frem <4 x float> %62, %68
  %70 = load <4 x float>* %v
  %v22 = fadd <4 x float> %70, %69
  store <4 x float> %v22, <4 x float>* %v
  %71 = load <4 x float>* %v
  %72 = load <4 x float> addrspace(2)* @uv4
  %73 = call <4 x float> @llvm.gla.fMin.v4f32.v4f32.v4f32(<4 x float> %71, <4 x float> %72)
  %74 = load <4 x float>* %v
  %v23 = fadd <4 x float> %74, %73
  store <4 x float> %v23, <4 x float>* %v
  %75 = load <4 x float>* %v
  %76 = load <4 x float> addrspace(2)* @uv4
  %77 = call <4 x float> @llvm.gla.fMax.v4f32.v4f32.v4f32(<4 x float> %75, <4 x float> %76)
  %78 = load <4 x float>* %v
  %v24 = fadd <4 x float> %78, %77
  store <4 x float> %v24, <4 x float>* %v
  %79 = load <4 x float>* %v
  %80 = load <4 x float> addrspace(2)* @uv4
  %81 = load <4 x float> addrspace(2)* @uv4
  %82 = call <4 x float> @llvm.gla.fClamp.v4f32.v4f32.v4f32.v4f32(<4 x float> %79, <4 x float> %80, <4 x float> %81)
  %83 = load <4 x float>* %v
  %v25 = fadd <4 x float> %83, %82
  store <4 x float> %v25, <4 x float>* %v
  %84 = load <4 x float>* %v
  %85 = load <4 x float>* %v
  %86 = load <4 x float>* %v
  %87 = call <4 x float> @llvm.gla.fMix.v4f32.v4f32.v4f32.v4f32(<4 x float> %84, <4 x float> %85, <4 x float> %86)
  %88 = load <4 x float>* %v
  %v26 = fadd <4 x float> %88, %87
  store <4 x float> %v26, <4 x float>* %v
  %89 = load <4 x float>* %v
  %90 = load <4 x float>* %v
  %91 = call <4 x float> @llvm.gla.fStep.v4f32.v4f32.v4f32(<4 x float> %89, <4 x float> %90)
  %92 = load <4 x float>* %v
  %v27 = fadd <4 x float> %92, %91
  store <4 x float> %v27, <4 x float>* %v
  %93 = load <4 x float>* %v
  %94 = load <4 x float>* %v
  %95 = load <4 x float>* %v
  %96 = call <4 x float> @llvm.gla.fSmoothStep.v4f32.v4f32.v4f32.v4f32(<4 x float> %93, <4 x float> %94, <4 x float> %95)
  %97 = load <4 x float>* %v
  %v28 = fadd <4 x float> %97, %96
  store <4 x float> %v28, <4 x float>* %v
  %98 = load <4 x float>* %v
  %99 = call <4 x float> @llvm.gla.fNormalize.v4f32.v4f32(<4 x float> %98)
  %100 = load <4 x float>* %v
  %v29 = fadd <4 x float> %100, %99
  store <4 x float> %v29, <4 x float>* %v
  %101 = load <4 x float>* %v
  %102 = load <4 x float>* %v
  %103 = load <4 x float>* %v
  %104 = call <4 x float> @llvm.gla.fFaceForward.v4f32.v4f32.v4f32.v4f32(<4 x float> %101, <4 x float> %102, <4 x float> %103)
  %105 = load <4 x float>* %v
  %v30 = fadd <4 x float> %105, %104
  store <4 x float> %v30, <4 x float>* %v
  %106 = load <4 x float>* %v
  %107 = load <4 x float>* %v
  %108 = call <4 x float> @llvm.gla.fReflect.v4f32.v4f32.v4f32(<4 x float> %106, <4 x float> %107)
  %109 = load <4 x float>* %v
  %v31 = fadd <4 x float> %109, %108
  store <4 x float> %v31, <4 x float>* %v
  %110 = load <4 x float>* %v
  %111 = load <4 x float>* %v
  %112 = load float addrspace(2)* @uf
  %113 = call <4 x float> @llvm.gla.fRefract.v4f32.v4f32.v4f32.f32(<4 x float> %110, <4 x float> %111, float %112)
  %114 = load <4 x float>* %v
  %v32 = fadd <4 x float> %114, %113
  store <4 x float> %v32, <4 x float>* %v
  %115 = load <4 x float>* %v
  %116 = call <4 x float> @llvm.gla.fDFdx.v4f32.v4f32(<4 x float> %115)
  %117 = load <4 x float>* %v
  %v33 = fadd <4 x float> %117, %116
  store <4 x float> %v33, <4 x float>* %v
  %118 = load <4 x float>* %v
  %119 = call <4 x float> @llvm.gla.fDFdy.v4f32.v4f32(<4 x float> %118)
  %120 = load <4 x float>* %v
  %v34 = fadd <4 x float> %120, %119
  store <4 x float> %v34, <4 x float>* %v
  %121 = load <4 x float>* %v
  %122 = call <4 x float> @llvm.gla.fFilterWidth.v4f32.v4f32(<4 x float> %121)
  %123 = load <4 x float>* %v
  %v35 = fadd <4 x float> %123, %122
  store <4 x float> %v35, <4 x float>* %v
  %124 = load <4 x float>* %v
  %125 = load <4 x float> addrspace(2)* @uv4
  %126 = fcmp olt <4 x float> %124, %125
  %b36 = call i1 @llvm.gla.any.v4i1(<4 x i1> %126)
  store i1 %b36, i1* %b
  %127 = load i1* %b
  %128 = load <4 x float>* %v
  %129 = load <4 x float> addrspace(2)* @uv4
  %130 = fcmp ole <4 x float> %128, %129
  %131 = call i1 @llvm.gla.any.v4i1(<4 x i1> %130)
  %b37 = and i1 %127, %131
  store i1 %b37, i1* %b
  %132 = load i1* %b
  %133 = load <4 x float>* %v
  %134 = load <4 x float> addrspace(2)* @uv4
  %135 = fcmp ogt <4 x float> %133, %134
  %136 = call i1 @llvm.gla.any.v4i1(<4 x i1> %135)
  %b38 = and i1 %132, %136
  store i1 %b38, i1* %b
  %137 = load i1* %b
  %138 = load <4 x float>* %v
  %139 = load <4 x float> addrspace(2)* @uv4
  %140 = fcmp oge <4 x float> %138, %139
  %141 = call i1 @llvm.gla.any.v4i1(<4 x i1> %140)
  %b39 = and i1 %137, %141
  store i1 %b39, i1* %b
  %142 = load i1* %b
  %143 = load <4 x i1> addrspace(2)* @ub41
  %144 = load <4 x i1> addrspace(2)* @ub42
  %145 = icmp eq <4 x i1> %143, %144
  %146 = call i1 @llvm.gla.any.v4i1(<4 x i1> %145)
  %b40 = and i1 %142, %146
  store i1 %b40, i1* %b
  %147 = load i1* %b
  %148 = load <4 x i1> addrspace(2)* @ub41
  %149 = load <4 x i1> addrspace(2)* @ub42
  %150 = icmp ne <4 x i1> %148, %149
  %151 = call i1 @llvm.gla.any.v4i1(<4 x i1> %150)
  %b41 = and i1 %147, %151
  store i1 %b41, i1* %b
  %152 = load i1* %b
  %153 = load <4 x i1> addrspace(2)* @ub41
  %154 = call i1 @llvm.gla.any.v4i1(<4 x i1> %153)
  %b42 = and i1 %152, %154
  store i1 %b42, i1* %b
  %155 = load i1* %b
  %156 = load <4 x i1> addrspace(2)* @ub41
  %157 = call i1 @llvm.gla.all.v4i1(<4 x i1> %156)
  %b43 = and i1 %155, %157
  store i1 %b43, i1* %b
  %158 = load i1* %b
  %159 = load <4 x i1> addrspace(2)* @ub41
  %160 = xor <4 x i1> %159, <i1 true, i1 true, i1 true, i1 true>
  %161 = call i1 @llvm.gla.any.v4i1(<4 x i1> %160)
  %b44 = and i1 %158, %161
  store i1 %b44, i1* %b
  %162 = load i32* %i
  %163 = load i32 addrspace(2)* @ui
  %164 = add i32 %162, %163
  %165 = load i32* %i
  %166 = mul i32 %164, %165
  %167 = load i32 addrspace(2)* @ui
  %168 = sub i32 %166, %167
  %169 = load i32* %i
  %i45 = sdiv i32 %168, %169
  store i32 %i45, i32* %i
  %170 = load i32* %i
  %171 = load i32 addrspace(2)* @ui
  %i46 = srem i32 %170, %171
  store i32 %i46, i32* %i
  %172 = load i32* %i
  %173 = load i32 addrspace(2)* @ui
  %174 = icmp eq i32 %172, %173
  %175 = load i32* %i
  %176 = load i32 addrspace(2)* @ui
  %177 = icmp ne i32 %175, %176
  %178 = load i32* %i
  %179 = load i32 addrspace(2)* @ui
  %180 = icmp eq i32 %178, %179
  %181 = and i1 %177, %180
  %182 = load i32* %i
  %183 = icmp ne i32 %182, 2
  %184 = xor i1 %181, %183
  %185 = or i1 %174, %184
  br i1 %185, label %then, label %ifmerge

then:                                             ; preds = %entry
  %186 = load i32* %i
  %i47 = add i32 %186, 1
  store i32 %i47, i32* %i
  br label %ifmerge

ifmerge:                                          ; preds = %entry, %then
  %187 = load float addrspace(2)* @uf
  %188 = load float addrspace(2)* @uf
  %189 = fadd float %187, %188
  %190 = load float addrspace(2)* @uf
  %191 = fmul float %189, %190
  %192 = load float addrspace(2)* @uf
  %193 = fsub float %191, %192
  %194 = load float addrspace(2)* @uf
  %f48 = fdiv float %193, %194
  store float %f48, float* %f
  %195 = load <4 x float>* %v
  %196 = call float @llvm.gla.fLength.f32.v4f32(<4 x float> %195)
  %197 = load float* %f
  %f49 = fadd float %197, %196
  store float %f49, float* %f
  %198 = load <4 x float>* %v
  %199 = load <4 x float>* %v
  %200 = call float @llvm.gla.fDistance.f32.v4f32.v4f32(<4 x float> %198, <4 x float> %199)
  %201 = load float* %f
  %f50 = fadd float %201, %200
  store float %f50, float* %f
  %202 = load <4 x float>* %v
  %203 = load <4 x float>* %v
  %204 = call float @llvm.gla.fDot4.f32.v4f32.v4f32(<4 x float> %202, <4 x float> %203)
  %205 = load float* %f
  %f51 = fadd float %205, %204
  store float %f51, float* %f
  %206 = load <4 x float>* %v
  %207 = extractelement <4 x float> %206, i32 0
  %208 = insertelement <3 x float> undef, float %207, i32 0
  %209 = extractelement <4 x float> %206, i32 1
  %210 = insertelement <3 x float> %208, float %209, i32 1
  %211 = extractelement <4 x float> %206, i32 2
  %212 = insertelement <3 x float> %210, float %211, i32 2
  %213 = load <4 x float>* %v
  %214 = extractelement <4 x float> %213, i32 0
  %215 = insertelement <3 x float> undef, float %214, i32 0
  %216 = extractelement <4 x float> %213, i32 1
  %217 = insertelement <3 x float> %215, float %216, i32 1
  %218 = extractelement <4 x float> %213, i32 2
  %219 = insertelement <3 x float> %217, float %218, i32 2
  %220 = call <3 x float> @llvm.gla.fCross.v3f32.v3f32.v3f32(<3 x float> %212, <3 x float> %219)
  %221 = extractelement <3 x float> %220, i32 0
  %222 = load float* %f
  %f52 = fadd float %222, %221
  store float %f52, float* %f
  %223 = load float* %f
  %224 = load float addrspace(2)* @uf
  %225 = fcmp oeq float %223, %224
  %226 = load float* %f
  %227 = load float addrspace(2)* @uf
  %228 = fcmp one float %226, %227
  %229 = load float* %f
  %230 = fcmp one float %229, 2.000000e+00
  %231 = and i1 %228, %230
  %232 = or i1 %225, %231
  br i1 %232, label %then53, label %ifmerge55

then53:                                           ; preds = %ifmerge
  %233 = load float* %f
  %f54 = fadd float %233, 1.000000e+00
  store float %f54, float* %f
  br label %ifmerge55

ifmerge55:                                        ; preds = %ifmerge, %then53
  %234 = load i32 addrspace(2)* @ui
  %235 = load i32* %i
  %i56 = and i32 %235, %234
  store i32 %i56, i32* %i
  %236 = load i32* %i
  %i57 = or i32 %236, 66
  store i32 %i57, i32* %i
  %237 = load i32 addrspace(2)* @ui
  %238 = load i32* %i
  %i58 = xor i32 %238, %237
  store i32 %i58, i32* %i
  %239 = load i32* %i
  %i59 = srem i32 %239, 17
  store i32 %i59, i32* %i
  %240 = load i32* %i
  %i60 = ashr i32 %240, 2
  store i32 %i60, i32* %i
  %241 = load i32 addrspace(2)* @ui
  %242 = load i32* %i
  %i61 = shl i32 %242, %241
  store i32 %i61, i32* %i
  %243 = load i32* %i
  %i62 = xor i32 %243, -1
  store i32 %i62, i32* %i
  %244 = load i1* %b
  %b63 = xor i1 %244, true
  store i1 %b63, i1* %b
  %245 = load i1* %b
  br i1 %245, label %then64, label %else

then64:                                           ; preds = %ifmerge55
  %246 = load i32* %i
  %247 = sitofp i32 %246 to float
  %248 = load <4 x float>* %constructed
  %249 = insertelement <4 x float> undef, float %247, i32 0
  %250 = insertelement <4 x float> %249, float %247, i32 1
  %251 = insertelement <4 x float> %250, float %247, i32 2
  %252 = insertelement <4 x float> %251, float %247, i32 3
  %253 = load float* %f
  %254 = load <4 x float>* %constructed65
  %255 = insertelement <4 x float> undef, float %253, i32 0
  %256 = insertelement <4 x float> %255, float %253, i32 1
  %257 = insertelement <4 x float> %256, float %253, i32 2
  %258 = insertelement <4 x float> %257, float %253, i32 3
  %259 = fadd <4 x float> %252, %258
  %260 = load <4 x float>* %v
  %ternary66 = fadd <4 x float> %259, %260
  store <4 x float> %ternary66, <4 x float>* %ternary
  br label %ifmerge68

else:                                             ; preds = %ifmerge55
  %ternary67 = load <4 x float>* %v
  store <4 x float> %ternary67, <4 x float>* %ternary
  br label %ifmerge68

ifmerge68:                                        ; preds = %else, %then64
  %FragColor_shadow = load <4 x float>* %ternary
  store <4 x float> %FragColor_shadow, <4 x float>* @FragColor_shadow
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %ifmerge68
  %261 = load <4 x float>* @FragColor_shadow
  call void @llvm.gla.fWriteData.v4f32(i32 0, i32 -1, <4 x float> %261)
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

declare <4 x float> @llvm.gla.fRadians.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fDegrees.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fSin.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fCos.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fTan.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fAsin.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fAcos.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fPow.v4f32.v4f32.v4f32(<4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fExp.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fLog.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fExp2.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fLog2.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fSqrt.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fInverseSqrt.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fAbs.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fSign.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fFloor.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fCeiling.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fFraction.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fMin.v4f32.v4f32.v4f32(<4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fMax.v4f32.v4f32.v4f32(<4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fClamp.v4f32.v4f32.v4f32.v4f32(<4 x float>, <4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fMix.v4f32.v4f32.v4f32.v4f32(<4 x float>, <4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fStep.v4f32.v4f32.v4f32(<4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fSmoothStep.v4f32.v4f32.v4f32.v4f32(<4 x float>, <4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fNormalize.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fFaceForward.v4f32.v4f32.v4f32.v4f32(<4 x float>, <4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fReflect.v4f32.v4f32.v4f32(<4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fRefract.v4f32.v4f32.v4f32.f32(<4 x float>, <4 x float>, float) nounwind readnone

declare <4 x float> @llvm.gla.fDFdx.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fDFdy.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fFilterWidth.v4f32.v4f32(<4 x float>) nounwind readnone

declare i1 @llvm.gla.any.v4i1(<4 x i1>) nounwind readnone

declare i1 @llvm.gla.all.v4i1(<4 x i1>) nounwind readnone

declare float @llvm.gla.fLength.f32.v4f32(<4 x float>) nounwind readnone

declare float @llvm.gla.fDistance.f32.v4f32.v4f32(<4 x float>, <4 x float>) nounwind readnone

declare float @llvm.gla.fDot4.f32.v4f32.v4f32(<4 x float>, <4 x float>) nounwind readnone

declare <3 x float> @llvm.gla.fCross.v3f32.v3f32.v3f32(<3 x float>, <3 x float>) nounwind readnone

declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) nounwind


Bottom IR:
; ModuleID = 'Top'

@uv4 = external addrspace(2) constant <4 x float>
@ui = external addrspace(2) constant i32
@uf = external addrspace(2) constant float
@ub41 = external addrspace(2) constant <4 x i1>
@ub42 = external addrspace(2) constant <4 x i1>

define fastcc void @main() {
entry:
  %0 = load <4 x float> addrspace(2)* @uv4, align 16
  %1 = fmul <4 x float> %0, <float 0x3F91DF46A0000000, float 0x3F91DF46A0000000, float 0x3F91DF46A0000000, float 0x3F91DF46A0000000>
  %2 = fmul <4 x float> %1, <float 0x404CA5DC20000000, float 0x404CA5DC20000000, float 0x404CA5DC20000000, float 0x404CA5DC20000000>
  %v2 = fadd <4 x float> %1, %2
  %3 = load i32 addrspace(2)* @ui, align 4
  %i3 = mul i32 %3, %3
  %4 = call <4 x float> @llvm.gla.fSin.v4f32.v4f32(<4 x float> %v2)
  %v4 = fadd <4 x float> %4, %v2
  %5 = call <4 x float> @llvm.gla.fCos.v4f32.v4f32(<4 x float> %v4)
  %v5 = fadd <4 x float> %5, %v4
  %6 = call <4 x float> @llvm.gla.fTan.v4f32.v4f32(<4 x float> %v5)
  %v6 = fadd <4 x float> %6, %v5
  %7 = call <4 x float> @llvm.gla.fAsin.v4f32.v4f32(<4 x float> %v6)
  %v7 = fadd <4 x float> %7, %v6
  %8 = call <4 x float> @llvm.gla.fAcos.v4f32.v4f32(<4 x float> %v7)
  %v8 = fadd <4 x float> %8, %v7
  %9 = call <4 x float> @llvm.gla.fPow.v4f32.v4f32.v4f32(<4 x float> %v8, <4 x float> %v8)
  %v9 = fadd <4 x float> %9, %v8
  %10 = call <4 x float> @llvm.gla.fExp.v4f32.v4f32(<4 x float> %v9)
  %v10 = fadd <4 x float> %10, %v9
  %11 = call <4 x float> @llvm.gla.fLog.v4f32.v4f32(<4 x float> %v10)
  %v11 = fadd <4 x float> %11, %v10
  %12 = call <4 x float> @llvm.gla.fExp2.v4f32.v4f32(<4 x float> %v11)
  %v12 = fadd <4 x float> %12, %v11
  %13 = call <4 x float> @llvm.gla.fLog2.v4f32.v4f32(<4 x float> %v12)
  %v13 = fadd <4 x float> %13, %v12
  %14 = call <4 x float> @llvm.gla.fSqrt.v4f32.v4f32(<4 x float> %v13)
  %v14 = fadd <4 x float> %14, %v13
  %15 = call <4 x float> @llvm.gla.fInverseSqrt.v4f32.v4f32(<4 x float> %v14)
  %v15 = fadd <4 x float> %15, %v14
  %16 = call <4 x float> @llvm.gla.fAbs.v4f32.v4f32(<4 x float> %v15)
  %v16 = fadd <4 x float> %16, %v15
  %17 = call <4 x float> @llvm.gla.fSign.v4f32.v4f32(<4 x float> %v16)
  %v17 = fadd <4 x float> %17, %v16
  %18 = call <4 x float> @llvm.gla.fFloor.v4f32.v4f32(<4 x float> %v17)
  %v18 = fadd <4 x float> %18, %v17
  %19 = call <4 x float> @llvm.gla.fCeiling.v4f32.v4f32(<4 x float> %v18)
  %v19 = fadd <4 x float> %19, %v18
  %20 = call <4 x float> @llvm.gla.fFraction.v4f32.v4f32(<4 x float> %v19)
  %v20 = fadd <4 x float> %20, %v19
  %21 = frem <4 x float> %v20, %v20
  %v21 = fadd <4 x float> %21, %v20
  %22 = call <4 x float> @llvm.gla.fSwizzle.v4f32.v4f32.v4i32(<4 x float> %v21, <4 x i32> zeroinitializer)
  %23 = frem <4 x float> %v21, %22
  %v22 = fadd <4 x float> %23, %v21
  %24 = call <4 x float> @llvm.gla.fMin.v4f32.v4f32.v4f32(<4 x float> %v22, <4 x float> %0)
  %v23 = fadd <4 x float> %24, %v22
  %25 = call <4 x float> @llvm.gla.fMax.v4f32.v4f32.v4f32(<4 x float> %v23, <4 x float> %0)
  %v24 = fadd <4 x float> %25, %v23
  %26 = call <4 x float> @llvm.gla.fClamp.v4f32.v4f32.v4f32.v4f32(<4 x float> %v24, <4 x float> %0, <4 x float> %0)
  %v25 = fadd <4 x float> %26, %v24
  %27 = call <4 x float> @llvm.gla.fMix.v4f32.v4f32.v4f32.v4f32(<4 x float> %v25, <4 x float> %v25, <4 x float> %v25)
  %v26 = fadd <4 x float> %27, %v25
  %28 = call <4 x float> @llvm.gla.fStep.v4f32.v4f32.v4f32(<4 x float> %v26, <4 x float> %v26)
  %v27 = fadd <4 x float> %28, %v26
  %29 = call <4 x float> @llvm.gla.fSmoothStep.v4f32.v4f32.v4f32.v4f32(<4 x float> %v27, <4 x float> %v27, <4 x float> %v27)
  %v28 = fadd <4 x float> %29, %v27
  %30 = call <4 x float> @llvm.gla.fNormalize.v4f32.v4f32(<4 x float> %v28)
  %v29 = fadd <4 x float> %30, %v28
  %31 = call <4 x float> @llvm.gla.fFaceForward.v4f32.v4f32.v4f32.v4f32(<4 x float> %v29, <4 x float> %v29, <4 x float> %v29)
  %v30 = fadd <4 x float> %31, %v29
  %32 = call <4 x float> @llvm.gla.fReflect.v4f32.v4f32.v4f32(<4 x float> %v30, <4 x float> %v30)
  %v31 = fadd <4 x float> %32, %v30
  %33 = load float addrspace(2)* @uf, align 4
  %34 = call <4 x float> @llvm.gla.fRefract.v4f32.v4f32.v4f32.f32(<4 x float> %v31, <4 x float> %v31, float %33)
  %v32 = fadd <4 x float> %v31, %34
  %35 = call <4 x float> @llvm.gla.fDFdx.v4f32.v4f32(<4 x float> %v32)
  %v33 = fadd <4 x float> %v32, %35
  %36 = call <4 x float> @llvm.gla.fDFdy.v4f32.v4f32(<4 x float> %v33)
  %v34 = fadd <4 x float> %v33, %36
  %37 = call <4 x float> @llvm.gla.fFilterWidth.v4f32.v4f32(<4 x float> %v34)
  %v35 = fadd <4 x float> %v34, %37
  %38 = call <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float> %v35, <3 x i32> <i32 0, i32 1, i32 2>)
  %39 = fcmp olt <4 x float> %v35, %0
  %b36 = call i1 @llvm.gla.any.v4i1(<4 x i1> %39)
  %40 = fcmp ole <4 x float> %v35, %0
  %41 = call i1 @llvm.gla.any.v4i1(<4 x i1> %40)
  %b37 = and i1 %b36, %41
  %42 = fcmp ogt <4 x float> %v35, %0
  %43 = call i1 @llvm.gla.any.v4i1(<4 x i1> %42)
  %b38 = and i1 %b37, %43
  %44 = fcmp oge <4 x float> %v35, %0
  %45 = call i1 @llvm.gla.any.v4i1(<4 x i1> %44)
  %b39 = and i1 %b38, %45
  %46 = load <4 x i1> addrspace(2)* @ub41, align 4
  %47 = load <4 x i1> addrspace(2)* @ub42, align 4
  %48 = icmp eq <4 x i1> %46, %47
  %49 = call i1 @llvm.gla.any.v4i1(<4 x i1> %48)
  %b40 = and i1 %b39, %49
  %50 = icmp ne <4 x i1> %46, %47
  %51 = call i1 @llvm.gla.any.v4i1(<4 x i1> %50)
  %b41 = and i1 %b40, %51
  %52 = call i1 @llvm.gla.any.v4i1(<4 x i1> %46)
  %b42 = and i1 %b41, %52
  %53 = call i1 @llvm.gla.all.v4i1(<4 x i1> %46)
  %b43 = and i1 %b42, %53
  %54 = xor <4 x i1> %46, <i1 true, i1 true, i1 true, i1 true>
  %55 = call i1 @llvm.gla.any.v4i1(<4 x i1> %54)
  %b44 = and i1 %b43, %55
  %56 = add i32 %i3, %3
  %57 = mul i32 %56, %i3
  %58 = sub i32 %57, %3
  %i45 = sdiv i32 %58, %i3
  %i46 = srem i32 %i45, %3
  %59 = icmp eq i32 %i46, 2
  %i47 = add i32 %i46, 1
  %i.0 = select i1 %59, i32 0, i32 %i47
  %60 = fadd float %33, %33
  %61 = fmul float %33, %60
  %62 = fsub float %61, %33
  %f48 = fdiv float %62, %33
  %63 = call float @llvm.gla.fLength.f32.v4f32(<4 x float> %v35)
  %f49 = fadd float %f48, %63
  %64 = call float @llvm.gla.fDot4.f32.v4f32.v4f32(<4 x float> %v35, <4 x float> %v35)
  %f51 = fadd float %f49, %64
  %65 = call <3 x float> @llvm.gla.fCross.v3f32.v3f32.v3f32(<3 x float> %38, <3 x float> %38)
  %66 = extractelement <3 x float> %65, i32 0
  %f52 = fadd float %f51, %66
  %67 = fcmp oeq float %f52, %33
  %68 = fcmp one float %f52, %33
  %69 = fcmp one float %f52, 2.000000e+00
  %70 = and i1 %68, %69
  %71 = or i1 %67, %70
  %f54 = fadd float %f52, 1.000000e+00
  %select70 = select i1 %71, float %f54, float %f52
  %72 = call <4 x float> @llvm.gla.fSwizzle.v4f32.f32.v4i32(float %select70, <4 x i32> zeroinitializer)
  %i56 = and i32 %3, %i.0
  %i57 = or i32 %i56, 66
  %i58 = xor i32 %i57, %3
  %i59 = srem i32 %i58, 17
  %i60 = ashr i32 %i59, 2
  %i61 = shl i32 %i60, %3
  %i62 = xor i32 %i61, -1
  %73 = sitofp i32 %i62 to float
  %74 = call <4 x float> @llvm.gla.fSwizzle.v4f32.f32.v4i32(float %73, <4 x i32> zeroinitializer)
  %75 = fadd <4 x float> %74, %72
  %ternary66 = fadd <4 x float> %v35, %75
  %select = select i1 %b44, <4 x float> %v35, <4 x float> %ternary66
  call void @llvm.gla.fWriteData.v4f32(i32 0, i32 -1, <4 x float> %select)
  br label %stage-epilogue

stage-epilogue:                                   ; preds = %entry
  br label %stage-exit

stage-exit:                                       ; preds = %stage-epilogue
  ret void
}

declare <4 x float> @llvm.gla.fSin.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fCos.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fTan.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fAsin.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fAcos.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fPow.v4f32.v4f32.v4f32(<4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fExp.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fLog.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fExp2.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fLog2.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fSqrt.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fInverseSqrt.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fAbs.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fSign.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fFloor.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fCeiling.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fFraction.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fMin.v4f32.v4f32.v4f32(<4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fMax.v4f32.v4f32.v4f32(<4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fClamp.v4f32.v4f32.v4f32.v4f32(<4 x float>, <4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fMix.v4f32.v4f32.v4f32.v4f32(<4 x float>, <4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fStep.v4f32.v4f32.v4f32(<4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fSmoothStep.v4f32.v4f32.v4f32.v4f32(<4 x float>, <4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fNormalize.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fFaceForward.v4f32.v4f32.v4f32.v4f32(<4 x float>, <4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fReflect.v4f32.v4f32.v4f32(<4 x float>, <4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fRefract.v4f32.v4f32.v4f32.f32(<4 x float>, <4 x float>, float) nounwind readnone

declare <4 x float> @llvm.gla.fDFdx.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fDFdy.v4f32.v4f32(<4 x float>) nounwind readnone

declare <4 x float> @llvm.gla.fFilterWidth.v4f32.v4f32(<4 x float>) nounwind readnone

declare i1 @llvm.gla.any.v4i1(<4 x i1>) nounwind readnone

declare i1 @llvm.gla.all.v4i1(<4 x i1>) nounwind readnone

declare float @llvm.gla.fLength.f32.v4f32(<4 x float>) nounwind readnone

declare float @llvm.gla.fDot4.f32.v4f32.v4f32(<4 x float>, <4 x float>) nounwind readnone

declare <3 x float> @llvm.gla.fCross.v3f32.v3f32.v3f32(<3 x float>, <3 x float>) nounwind readnone

declare void @llvm.gla.fWriteData.v4f32(i32, i32, <4 x float>) nounwind

declare <4 x float> @llvm.gla.fSwizzle.v4f32.v4f32.v4i32(<4 x float>, <4 x i32>) nounwind readnone

declare <3 x float> @llvm.gla.fSwizzle.v3f32.v4f32.v3i32(<4 x float>, <3 x i32>) nounwind readnone

declare <4 x float> @llvm.gla.fSwizzle.v4f32.f32.v4i32(float, <4 x i32>) nounwind readnone
#### BEGIN COMPILER 0 INFO LOG ####
#### END COMPILER 0 INFO LOG ####
#### BEGIN LINKER INFO LOG ####
#### END LINKER INFO LOG ####

// LunarGOO(r722) output
#version 130
uniform vec4 uv4;
uniform int ui;
uniform float uf;
uniform bvec4 ub41;
uniform bvec4 ub42;
const vec4 const22 = vec4(0.0174533);
const vec4 const24 = vec4(57.2958);
const int const123i_2 = 2;
const int const125i_1 = 1;
const int const127i_0 = 0;
const float const141f_2 = 2.0;
const float const145f_1 = 1.0;
const int const150i_66 = 66;
const int const153i_17 = 17;

void main()
{
    vec4 temp21 = uv4 * const22;
    vec4 temp23 = temp21 * const24;
    vec4 temp25 = temp21 + temp23;
    int temp26 = ui * ui;
    vec4 temp27 = sin(temp25);
    vec4 temp28 = temp27 + temp25;
    vec4 temp29 = cos(temp28);
    vec4 temp30 = temp29 + temp28;
    vec4 temp31 = tan(temp30);
    vec4 temp32 = temp31 + temp30;
    vec4 temp33 = asin(temp32);
    vec4 temp34 = temp33 + temp32;
    vec4 temp35 = acos(temp34);
    vec4 temp36 = temp35 + temp34;
    vec4 temp37 = pow(temp36, temp36);
    vec4 temp38 = temp37 + temp36;
    vec4 temp39 = exp(temp38);
    vec4 temp40 = temp39 + temp38;
    vec4 temp41 = log(temp40);
    vec4 temp42 = temp41 + temp40;
    vec4 temp43 = exp2(temp42);
    vec4 temp44 = temp43 + temp42;
    vec4 temp45 = log2(temp44);
    vec4 temp46 = temp45 + temp44;
    vec4 temp47 = sqrt(temp46);
    vec4 temp48 = temp47 + temp46;
    vec4 temp49 = inversesqrt(temp48);
    vec4 temp50 = temp49 + temp48;
    vec4 temp51 = abs(temp50);
    vec4 temp52 = temp51 + temp50;
    vec4 temp53 = sign(temp52);
    vec4 temp54 = temp53 + temp52;
    vec4 temp55 = floor(temp54);
    vec4 temp56 = temp55 + temp54;
    vec4 temp57 = ceil(temp56);
    vec4 temp58 = temp57 + temp56;
    vec4 temp59 = fract(temp58);
    vec4 temp60 = temp59 + temp58;
    vec4 temp61 = mod(temp60, temp60);
    vec4 temp62 = temp61 + temp60;
    vec4 temp63 = temp62.xxxx;
    vec4 temp64 = mod(temp62, temp63);
    vec4 temp65 = temp64 + temp62;
    vec4 temp66 = min(temp65, uv4);
    vec4 temp67 = temp66 + temp65;
    vec4 temp68 = max(temp67, uv4);
    vec4 temp69 = temp68 + temp67;
    vec4 temp70 = clamp(temp69, uv4, uv4);
    vec4 temp71 = temp70 + temp69;
    vec4 temp72 = mix(temp71, temp71, temp71);
    vec4 temp73 = temp72 + temp71;
    vec4 temp74 = step(temp73, temp73);
    vec4 temp75 = temp74 + temp73;
    vec4 temp76 = smoothstep(temp75, temp75, temp75);
    vec4 temp77 = temp76 + temp75;
    vec4 temp78 = normalize(temp77);
    vec4 temp79 = temp78 + temp77;
    vec4 temp80 = faceforward(temp79, temp79, temp79);
    vec4 temp81 = temp80 + temp79;
    vec4 temp82 = reflect(temp81, temp81);
    vec4 temp83 = temp82 + temp81;
    vec4 temp84 = refract(temp83, temp83, uf);
    vec4 temp85 = temp83 + temp84;
    vec4 temp86 = dFdx(temp85);
    vec4 temp87 = temp85 + temp86;
    vec4 temp88 = dFdy(temp87);
    vec4 temp89 = temp87 + temp88;
    vec4 temp90 = fwidth(temp89);
    vec4 temp91 = temp89 + temp90;
    vec3 temp92 = vec3(temp91);
    bvec4 temp93 = lessThan(temp91, uv4);
    bool temp94 = any(temp93);
    bvec4 temp95 = lessThanEqual(temp91, uv4);
    bool temp96 = any(temp95);
    bool temp97 = temp94 && temp96;
    bvec4 temp98 = greaterThan(temp91, uv4);
    bool temp99 = any(temp98);
    bool temp100 = temp97 && temp99;
    bvec4 temp101 = greaterThanEqual(temp91, uv4);
    bool temp102 = any(temp101);
    bool temp103 = temp100 && temp102;
    bvec4 temp104 = equal(ub41, ub42);
    bool temp105 = any(temp104);
    bool temp106 = temp103 && temp105;
    bvec4 temp107 = notEqual(ub41, ub42);
    bool temp108 = any(temp107);
    bool temp109 = temp106 && temp108;
    bool temp110 = any(ub41);
    bool temp111 = temp109 && temp110;
    bool temp112 = all(ub41);
    bool temp113 = temp111 && temp112;
    bvec4 temp114 = not(ub41);
    bool temp115 = any(temp114);
    bool temp116 = temp113 && temp115;
    int temp117 = temp26 + ui;
    int temp118 = temp117 * temp26;
    int temp119 = temp118 - ui;
    int temp120 = temp119 / temp26;
    int temp121 = temp120 % ui;
    bool temp122 = temp121 == const123i_2;
    int temp124 = temp121 + const125i_1;
    int id0 = temp122 ? const127i_0 : temp124;
    float temp128 = uf + uf;
    float temp129 = uf * temp128;
    float temp130 = temp129 - uf;
    float temp131 = temp130 / uf;
    float temp132 = length(temp91);
    float temp133 = temp131 + temp132;
    float temp134 = dot(temp91, temp91);
    float temp135 = temp133 + temp134;
    vec3 temp136 = cross(temp92, temp92);
    float temp137 = temp135 + temp136.x;
    bool temp138 = temp137 == uf;
    bool temp139 = temp137 != uf;
    bool temp140 = temp137 != const141f_2;
    bool temp142 = temp139 && temp140;
    bool temp143 = temp138 || temp142;
    float temp144 = temp137 + const145f_1;
    float select70 = temp143 ? temp144 : temp137;
    vec4 temp147 = vec4(select70);
    int temp148 = ui & id0;
    int temp149 = temp148 | const150i_66;
    int temp151 = temp149 ^ ui;
    int temp152 = temp151 % const153i_17;
    int temp154 = temp152 >> const123i_2;
    int temp155 = temp154 << ui;
    int temp156 = ~(temp155);
    float temp157 = float(temp156);
    vec4 temp158 = vec4(temp157);
    vec4 temp159 = temp158 + temp147;
    vec4 ternary66 = temp91 + temp159;
    vec4 select = temp116 ? temp91 : ternary66;
    gl_FragColor = select;
    
}
#### BEGIN COMPILER 0 INFO LOG ####
#### END COMPILER 0 INFO LOG ####
#### BEGIN LINKER INFO LOG ####
#### END LINKER INFO LOG ####

// LunarGOO(r722) output
#version 130
uniform vec4 uv4;
uniform int ui;
uniform float uf;
uniform bvec4 ub41;
uniform bvec4 ub42;
const vec4 const22 = vec4(0.0174533);
const vec4 const24 = vec4(57.2958);
const int const123i_2 = 2;
const int const125i_1 = 1;
const int const127i_0 = 0;
const float const141f_2 = 2.0;
const float const145f_1 = 1.0;
const int const150i_66 = 66;
const int const153i_17 = 17;

void main()
{
    vec4 temp211 = uv4 * const22;
    vec4 temp232 = temp211 * const24;
    vec4 temp253 = temp211 + temp232;
    int temp264 = ui * ui;
    vec4 temp275 = sin(temp253);
    vec4 temp286 = temp275 + temp253;
    vec4 temp297 = cos(temp286);
    vec4 temp308 = temp297 + temp286;
    vec4 temp319 = tan(temp308);
    vec4 temp3210 = temp319 + temp308;
    vec4 temp3311 = asin(temp3210);
    vec4 temp3412 = temp3311 + temp3210;
    vec4 temp3513 = acos(temp3412);
    vec4 temp3614 = temp3513 + temp3412;
    vec4 temp3715 = pow(temp3614, temp3614);
    vec4 temp3816 = temp3715 + temp3614;
    vec4 temp3917 = exp(temp3816);
    vec4 temp4018 = temp3917 + temp3816;
    vec4 temp4119 = log(temp4018);
    vec4 temp4220 = temp4119 + temp4018;
    vec4 temp4321 = exp2(temp4220);
    vec4 temp4422 = temp4321 + temp4220;
    vec4 temp4523 = log2(temp4422);
    vec4 temp4624 = temp4523 + temp4422;
    vec4 temp4725 = sqrt(temp4624);
    vec4 temp4826 = temp4725 + temp4624;
    vec4 temp4927 = inversesqrt(temp4826);
    vec4 temp5028 = temp4927 + temp4826;
    vec4 temp5129 = abs(temp5028);
    vec4 temp5230 = temp5129 + temp5028;
    vec4 temp5331 = sign(temp5230);
    vec4 temp5432 = temp5331 + temp5230;
    vec4 temp5533 = floor(temp5432);
    vec4 temp5634 = temp5533 + temp5432;
    vec4 temp5735 = ceil(temp5634);
    vec4 temp5836 = temp5735 + temp5634;
    vec4 temp5937 = fract(temp5836);
    vec4 temp6038 = temp5937 + temp5836;
    vec4 temp6139 = mod(temp6038, temp6038);
    vec4 temp6240 = temp6139 + temp6038;
    vec4 temp63 = temp6240.xxxx;
    vec4 temp6442 = mod(temp6240, temp63);
    vec4 temp6543 = temp6442 + temp6240;
    vec4 temp6644 = min(temp6543, uv4);
    vec4 temp6745 = temp6644 + temp6543;
    vec4 temp6846 = max(temp6745, uv4);
    vec4 temp6947 = temp6846 + temp6745;
    vec4 temp7048 = clamp(temp6947, uv4, uv4);
    vec4 temp7149 = temp7048 + temp6947;
    vec4 temp7250 = mix(temp7149, temp7149, temp7149);
    vec4 temp7351 = temp7250 + temp7149;
    vec4 temp7452 = step(temp7351, temp7351);
    vec4 temp7553 = temp7452 + temp7351;
    vec4 temp7654 = smoothstep(temp7553, temp7553, temp7553);
    vec4 temp7755 = temp7654 + temp7553;
    vec4 temp7856 = normalize(temp7755);
    vec4 temp7957 = temp7856 + temp7755;
    vec4 temp8058 = faceforward(temp7957, temp7957, temp7957);
    vec4 temp8159 = temp8058 + temp7957;
    vec4 temp8260 = reflect(temp8159, temp8159);
    vec4 temp8361 = temp8260 + temp8159;
    vec4 temp8462 = refract(temp8361, temp8361, uf);
    vec4 temp8563 = temp8361 + temp8462;
    vec4 temp8664 = dFdx(temp8563);
    vec4 temp8765 = temp8563 + temp8664;
    vec4 temp8866 = dFdy(temp8765);
    vec4 temp8967 = temp8765 + temp8866;
    vec4 temp9068 = fwidth(temp8967);
    vec4 temp9169 = temp8967 + temp9068;
    vec3 temp92 = vec3(temp9169);
    bvec4 temp9371 = lessThan(temp9169, uv4);
    bool temp9472 = any(temp9371);
    bvec4 temp9573 = lessThanEqual(temp9169, uv4);
    bool temp9674 = any(temp9573);
    bool temp9775 = temp9472 && temp9674;
    bvec4 temp9876 = greaterThan(temp9169, uv4);
    bool temp9977 = any(temp9876);
    bool temp10078 = temp9775 && temp9977;
    bvec4 temp10179 = greaterThanEqual(temp9169, uv4);
    bool temp10280 = any(temp10179);
    bool temp10381 = temp10078 && temp10280;
    bvec4 temp10482 = equal(ub41, ub42);
    bool temp10583 = any(temp10482);
    bool temp10684 = temp10381 && temp10583;
    bvec4 temp10785 = notEqual(ub41, ub42);
    bool temp10886 = any(temp10785);
    bool temp10987 = temp10684 && temp10886;
    bool temp11088 = any(ub41);
    bool temp11189 = temp10987 && temp11088;
    bool temp11290 = all(ub41);
    bool temp11391 = temp11189 && temp11290;
    bvec4 temp11492 = not(ub41);
    bool temp11593 = any(temp11492);
    bool temp11694 = temp11391 && temp11593;
    int temp11795 = temp264 + ui;
    int temp11896 = temp11795 * temp264;
    int temp11997 = temp11896 - ui;
    int temp12098 = temp11997 / temp264;
    int temp12199 = temp12098 % ui;
    bool temp122100 = temp12199 == const123i_2;
    int temp124101 = temp12199 + const125i_1;
    int ternaryd0 = temp122100 ? const127i_0 : temp124101;
    float temp128104 = uf + uf;
    float temp129105 = uf * temp128104;
    float temp130106 = temp129105 - uf;
    float temp131107 = temp130106 / uf;
    float temp132108 = length(temp9169);
    float temp133109 = temp131107 + temp132108;
    float temp134110 = dot(temp9169, temp9169);
    float temp135111 = temp133109 + temp134110;
    vec3 temp136112 = cross(temp92, temp92);
    float temp137113 = temp135111 + temp136112.x;
    bool temp138114 = temp137113 == uf;
    bool temp139115 = temp137113 != uf;
    bool temp140116 = temp137113 != const141f_2;
    bool temp142117 = temp139115 && temp140116;
    bool temp143118 = temp138114 || temp142117;
    float temp144119 = temp137113 + const145f_1;
    float select = temp143118 ? temp144119 : temp137113;
    vec4 temp147 = vec4(select);
    int temp148129 = ui & ternaryd0;
    int temp149130 = temp148129 | const150i_66;
    int temp151131 = temp149130 ^ ui;
    int temp152132 = temp151131 % const153i_17;
    int temp154133 = temp152132 >> const123i_2;
    int temp155134 = temp154133 << ui;
    int temp156135 = ~(temp155134);
    float temp157136 = float(temp156135);
    vec4 temp158 = vec4(temp157136);
    vec4 temp159139 = temp158 + temp147;
    vec4 ternary66140 = temp9169 + temp159139;
    vec4 select149 = temp11694 ? temp9169 : ternary66140;
    gl_FragColor = select149;
    
}
